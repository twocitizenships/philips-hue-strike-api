{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalBootstrap = void 0;\n\nconst https = __importStar(require(\"https\"));\n\nconst Api_1 = require(\"../Api\");\n\nconst httpClient = __importStar(require(\"./HttpClientFetch\"));\n\nconst ApiError_1 = require(\"../../ApiError\");\n\nconst Transport_1 = require(\"./Transport\");\n\nconst sslCertificate_1 = require(\"./sslCertificate\");\n\nconst urlUtil_1 = require(\"./urlUtil\");\n\nconst DEBUG = /node-hue-api/.test(process.env.NODE_DEBUG || '');\nconst INITIAL_HTTPS_AGENT = new https.Agent({\n  rejectUnauthorized: false\n});\n\nclass LocalBootstrap {\n  /**\n   * Create a Local Network Bootstrap for connecting to the Hue Bridge. The connection is ALWAYS over TLS/HTTPS.\n   *\n   * @param {String} hostname The hostname or ip address of the hue bridge on the local network.\n   * @param {number=} port The port number for the connections, defaults to 443 and should not need to be specified in the majority of use cases.\n   */\n  constructor(hostname, rateLimits, port) {\n    this.baseUrl = (0, urlUtil_1.getHttpsUrl)(hostname, port || 443);\n    this.hostname = (0, urlUtil_1.cleanHostname)(hostname);\n    this.rateLimits = rateLimits;\n  }\n  /**\n   * Connects to the Hue Bridge using the local network.\n   *\n   * The connection will perform checks on the Hue Bridge TLS Certificate to verify it is correct before sending any\n   * sensitive information.\n   *\n   * @param {String=} username The username to use when connecting, can be null, but will severely limit the endpoints that you can call/access\n   * @param {String=} clientkey The clientkey for the user, used by the entertainment API, can be null\n   * @param {Number=} timeout The timeout for requests sent to the Hue Bridge. If not set will default to 20 seconds.\n   * @returns {Promise<Api>} The API for interacting with the hue bridge.\n   */\n\n\n  connect(username, clientkey, timeout) {\n    const self = this,\n          hostname = self.hostname,\n          baseUrl = self.baseUrl.href;\n    return httpClient.request({\n      method: 'GET',\n      url: `${baseUrl}api/config`,\n      json: true,\n      httpsAgent: INITIAL_HTTPS_AGENT,\n      timeout: getTimeout(timeout)\n    }).then(res => {\n      const bridgeId = res.data.bridgeid.toLowerCase();\n      return (0, sslCertificate_1.getSSLCertificate)(hostname).then(cert => {\n        const subjectCn = cert.subject.CN.toLowerCase();\n\n        if (DEBUG) {\n          console.log('Bridge Certificate:\\n' + `  subject:       ${JSON.stringify(cert.subject)}\\n` + `  issuer:        ${JSON.stringify(cert.subject)}\\n` + `  valid from:    ${cert.valid_from}\\n` + `  valid to:      ${cert.valid_to}\\n` + `  serial number: ${cert.serialNumber}\\n`);\n          console.log(`Performing validation of bridgeId \"${bridgeId}\" against certificate subject \"${subjectCn}\"; matched? ${subjectCn === bridgeId}`);\n        }\n\n        if (subjectCn === bridgeId) {\n          return new https.Agent({\n            keepAlive: true,\n            keepAliveMsecs: 10000,\n            maxSockets: 50,\n            // timeout: getTimeout(timeout), //node-fetch appears to ignore this\n            rejectUnauthorized: false // ca: cert.pemEncoded //TODO there are still issues here, as the certificate being self signed is failing somewhere deeper in TLS code\n\n          });\n        } else {\n          throw new ApiError_1.ApiError('The hue bridge certificate does not match the expected issuer');\n        }\n      }).catch(error => {\n        throw new ApiError_1.ApiError(error);\n      }).then(agent => {\n        const apiBaseUrl = `${baseUrl}api`,\n              fetchConfig = {\n          baseURL: apiBaseUrl,\n          httpsAgent: agent,\n          timeout: getTimeout(timeout)\n        },\n              transport = new Transport_1.Transport(httpClient.create(fetchConfig), this.rateLimits.transportRateLimit, username),\n              config = {\n          remote: false,\n          baseUrl: apiBaseUrl,\n          bridgeName: this.hostname,\n          clientKey: clientkey,\n          username: username\n        };\n        return new Api_1.Api(config, transport, this.rateLimits);\n      });\n    });\n  }\n\n}\n\nexports.LocalBootstrap = LocalBootstrap;\n\nfunction getTimeout(timeout) {\n  return timeout || 20000;\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/node-hue-api/dist/cjs/api/http/LocalBootstrap.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","LocalBootstrap","https","require","Api_1","httpClient","ApiError_1","Transport_1","sslCertificate_1","urlUtil_1","DEBUG","test","process","env","NODE_DEBUG","INITIAL_HTTPS_AGENT","Agent","rejectUnauthorized","constructor","hostname","rateLimits","port","baseUrl","getHttpsUrl","cleanHostname","connect","username","clientkey","timeout","self","href","request","method","url","json","httpsAgent","getTimeout","then","res","bridgeId","data","bridgeid","toLowerCase","getSSLCertificate","cert","subjectCn","subject","CN","console","log","JSON","stringify","valid_from","valid_to","serialNumber","keepAlive","keepAliveMsecs","maxSockets","ApiError","catch","error","agent","apiBaseUrl","fetchConfig","baseURL","transport","Transport","transportRateLimit","config","remote","bridgeName","clientKey","Api"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LocalBootstrap = void 0;\nconst https = __importStar(require(\"https\"));\nconst Api_1 = require(\"../Api\");\nconst httpClient = __importStar(require(\"./HttpClientFetch\"));\nconst ApiError_1 = require(\"../../ApiError\");\nconst Transport_1 = require(\"./Transport\");\nconst sslCertificate_1 = require(\"./sslCertificate\");\nconst urlUtil_1 = require(\"./urlUtil\");\nconst DEBUG = /node-hue-api/.test(process.env.NODE_DEBUG || '');\nconst INITIAL_HTTPS_AGENT = new https.Agent({\n    rejectUnauthorized: false\n});\nclass LocalBootstrap {\n    /**\n     * Create a Local Network Bootstrap for connecting to the Hue Bridge. The connection is ALWAYS over TLS/HTTPS.\n     *\n     * @param {String} hostname The hostname or ip address of the hue bridge on the local network.\n     * @param {number=} port The port number for the connections, defaults to 443 and should not need to be specified in the majority of use cases.\n     */\n    constructor(hostname, rateLimits, port) {\n        this.baseUrl = (0, urlUtil_1.getHttpsUrl)(hostname, port || 443);\n        this.hostname = (0, urlUtil_1.cleanHostname)(hostname);\n        this.rateLimits = rateLimits;\n    }\n    /**\n     * Connects to the Hue Bridge using the local network.\n     *\n     * The connection will perform checks on the Hue Bridge TLS Certificate to verify it is correct before sending any\n     * sensitive information.\n     *\n     * @param {String=} username The username to use when connecting, can be null, but will severely limit the endpoints that you can call/access\n     * @param {String=} clientkey The clientkey for the user, used by the entertainment API, can be null\n     * @param {Number=} timeout The timeout for requests sent to the Hue Bridge. If not set will default to 20 seconds.\n     * @returns {Promise<Api>} The API for interacting with the hue bridge.\n     */\n    connect(username, clientkey, timeout) {\n        const self = this, hostname = self.hostname, baseUrl = self.baseUrl.href;\n        return httpClient.request({\n            method: 'GET',\n            url: `${baseUrl}api/config`,\n            json: true,\n            httpsAgent: INITIAL_HTTPS_AGENT,\n            timeout: getTimeout(timeout),\n        }).then(res => {\n            const bridgeId = res.data.bridgeid.toLowerCase();\n            return (0, sslCertificate_1.getSSLCertificate)(hostname)\n                .then((cert) => {\n                const subjectCn = cert.subject.CN.toLowerCase();\n                if (DEBUG) {\n                    console.log('Bridge Certificate:\\n'\n                        + `  subject:       ${JSON.stringify(cert.subject)}\\n`\n                        + `  issuer:        ${JSON.stringify(cert.subject)}\\n`\n                        + `  valid from:    ${cert.valid_from}\\n`\n                        + `  valid to:      ${cert.valid_to}\\n`\n                        + `  serial number: ${cert.serialNumber}\\n`);\n                    console.log(`Performing validation of bridgeId \"${bridgeId}\" against certificate subject \"${subjectCn}\"; matched? ${subjectCn === bridgeId}`);\n                }\n                if (subjectCn === bridgeId) {\n                    return new https.Agent({\n                        keepAlive: true,\n                        keepAliveMsecs: 10000,\n                        maxSockets: 50,\n                        // timeout: getTimeout(timeout), //node-fetch appears to ignore this\n                        rejectUnauthorized: false,\n                        // ca: cert.pemEncoded //TODO there are still issues here, as the certificate being self signed is failing somewhere deeper in TLS code\n                    });\n                }\n                else {\n                    throw new ApiError_1.ApiError('The hue bridge certificate does not match the expected issuer');\n                }\n            }).catch(error => {\n                throw new ApiError_1.ApiError(error);\n            })\n                .then(agent => {\n                const apiBaseUrl = `${baseUrl}api`, fetchConfig = {\n                    baseURL: apiBaseUrl,\n                    httpsAgent: agent,\n                    timeout: getTimeout(timeout)\n                }, transport = new Transport_1.Transport(httpClient.create(fetchConfig), this.rateLimits.transportRateLimit, username), config = {\n                    remote: false,\n                    baseUrl: apiBaseUrl,\n                    bridgeName: this.hostname,\n                    clientKey: clientkey,\n                    username: username,\n                };\n                return new Api_1.Api(config, transport, this.rateLimits);\n            });\n        });\n    }\n}\nexports.LocalBootstrap = LocalBootstrap;\nfunction getTimeout(timeout) {\n    return timeout || 20000;\n}\n"]},"metadata":{},"sourceType":"script"}