{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transport = void 0;\n\nconst ApiError_1 = require(\"../../ApiError\");\n\nconst util_1 = require(\"../../util\");\n\nconst HueError_1 = require(\"../../HueError\");\n\nconst HueRateLimiter_1 = require(\"../HueRateLimiter\");\n\nclass Transport {\n  constructor(client, rateLimiterConfig, username) {\n    this._username = username;\n    this._client = client;\n    this._limiter = new HueRateLimiter_1.HueRateLimiter('', 'transport', rateLimiterConfig);\n  }\n\n  get limiter() {\n    return this._limiter;\n  }\n  /**\n   * Executes an API Endpoint Request.\n   * @param api The Api endpoint to perform a request against.\n   * @param parameters Any parameters specific to the request.\n   * @returns {Promise<any>} The promise for making the specified API request.\n   */\n\n\n  execute(api, parameters) {\n    let self = this,\n        limiter = this.limiter,\n        client = self._client,\n        requestParameters = Object.assign({\n      username: self._username\n    }, parameters),\n        promise;\n\n    if (!api) {\n      throw new Error('An API must be provided');\n    } // @ts-ignore\n\n\n    promise = limiter.schedule(() => {\n      return client.request(api.getRequest(requestParameters));\n    }).catch(err => {\n      // @ts-ignore\n      throw extractError(err, err.response);\n    }).then(res => {\n      // Errors can be contained in the object payload from a successful response code.\n      const errors = (0, util_1.parseErrors)(res.data);\n\n      if (errors) {\n        throw new ApiError_1.ApiError(errors[0]);\n      }\n\n      return res.data;\n    });\n\n    if (api.getErrorHandler()) {\n      // @ts-ignore\n      promise = promise.catch(api.getErrorHandler());\n    }\n\n    const postProcessing = api.getPostProcessing();\n\n    if (postProcessing) {\n      // Inject the request parameters into the post processing function\n      promise = promise.then(result => {\n        return postProcessing(result, requestParameters);\n      });\n    }\n\n    return promise;\n  }\n\n  refreshAuthorizationHeader(token) {\n    // Update the default common authorization header with the new bearer token\n    this._client.refreshAuthorizationHeader(`Bearer ${token}`);\n  }\n\n}\n\nexports.Transport = Transport;\n/**\n * Extracts an appropriate error from the provided details.\n *\n * @param {Error} err The captured Error.\n * @param {Object} response The underlying transport HTTP response object.\n * @returns {ApiError | HueError} The error extracted from the data provided\n */\n\nfunction extractError(err, response) {\n  var _a, _b;\n\n  if (!response) {\n    //TODO fetch leaks the API key in the URL, need to redact it\n    const error = new ApiError_1.ApiError(err.message); // Set the original stack trace here as the one for the error created is pretty much useless and obscures the real problem\n\n    error.stack = err.stack;\n    throw error;\n  }\n\n  const headers = response.headers,\n        authenticateHeader = headers ? headers['www-authenticate'] : null;\n  let hueError;\n\n  if (authenticateHeader) {\n    const errorMatch = /error=\"(.*?)\"/.exec(authenticateHeader),\n          errorDescriptionMatch = /error_description=\"(.*?)\"/.exec(authenticateHeader);\n    hueError = new HueError_1.HueError({\n      type: response.status,\n      message: (errorMatch ? errorMatch[1] : response.data) || 'Error',\n      description: errorDescriptionMatch ? errorDescriptionMatch[1] : undefined,\n      address: (_a = response.config) === null || _a === void 0 ? void 0 : _a.url\n    });\n  } else {\n    hueError = new HueError_1.HueError({\n      type: response.status,\n      message: response.data || 'Error',\n      address: (_b = response.config) === null || _b === void 0 ? void 0 : _b.url\n    });\n  }\n\n  return new ApiError_1.ApiError(hueError);\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/node-hue-api/dist/cjs/api/http/Transport.js"],"names":["Object","defineProperty","exports","value","Transport","ApiError_1","require","util_1","HueError_1","HueRateLimiter_1","constructor","client","rateLimiterConfig","username","_username","_client","_limiter","HueRateLimiter","limiter","execute","api","parameters","self","requestParameters","assign","promise","Error","schedule","request","getRequest","catch","err","extractError","response","then","res","errors","parseErrors","data","ApiError","getErrorHandler","postProcessing","getPostProcessing","result","refreshAuthorizationHeader","token","_a","_b","error","message","stack","headers","authenticateHeader","hueError","errorMatch","exec","errorDescriptionMatch","HueError","type","status","description","undefined","address","config","url"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst ApiError_1 = require(\"../../ApiError\");\nconst util_1 = require(\"../../util\");\nconst HueError_1 = require(\"../../HueError\");\nconst HueRateLimiter_1 = require(\"../HueRateLimiter\");\nclass Transport {\n    constructor(client, rateLimiterConfig, username) {\n        this._username = username;\n        this._client = client;\n        this._limiter = new HueRateLimiter_1.HueRateLimiter('', 'transport', rateLimiterConfig);\n    }\n    get limiter() {\n        return this._limiter;\n    }\n    /**\n     * Executes an API Endpoint Request.\n     * @param api The Api endpoint to perform a request against.\n     * @param parameters Any parameters specific to the request.\n     * @returns {Promise<any>} The promise for making the specified API request.\n     */\n    execute(api, parameters) {\n        let self = this, limiter = this.limiter, client = self._client, requestParameters = Object.assign({ username: self._username }, parameters), promise;\n        if (!api) {\n            throw new Error('An API must be provided');\n        }\n        // @ts-ignore\n        promise = limiter.schedule(() => {\n            return client.request(api.getRequest(requestParameters));\n        })\n            .catch((err) => {\n            // @ts-ignore\n            throw extractError(err, err.response);\n        })\n            .then((res) => {\n            // Errors can be contained in the object payload from a successful response code.\n            const errors = (0, util_1.parseErrors)(res.data);\n            if (errors) {\n                throw new ApiError_1.ApiError(errors[0]);\n            }\n            return res.data;\n        });\n        if (api.getErrorHandler()) {\n            // @ts-ignore\n            promise = promise.catch(api.getErrorHandler());\n        }\n        const postProcessing = api.getPostProcessing();\n        if (postProcessing) {\n            // Inject the request parameters into the post processing function\n            promise = promise.then((result) => {\n                return postProcessing(result, requestParameters);\n            });\n        }\n        return promise;\n    }\n    refreshAuthorizationHeader(token) {\n        // Update the default common authorization header with the new bearer token\n        this._client.refreshAuthorizationHeader(`Bearer ${token}`);\n    }\n}\nexports.Transport = Transport;\n/**\n * Extracts an appropriate error from the provided details.\n *\n * @param {Error} err The captured Error.\n * @param {Object} response The underlying transport HTTP response object.\n * @returns {ApiError | HueError} The error extracted from the data provided\n */\nfunction extractError(err, response) {\n    var _a, _b;\n    if (!response) {\n        //TODO fetch leaks the API key in the URL, need to redact it\n        const error = new ApiError_1.ApiError(err.message);\n        // Set the original stack trace here as the one for the error created is pretty much useless and obscures the real problem\n        error.stack = err.stack;\n        throw error;\n    }\n    const headers = response.headers, authenticateHeader = headers ? headers['www-authenticate'] : null;\n    let hueError;\n    if (authenticateHeader) {\n        const errorMatch = /error=\"(.*?)\"/.exec(authenticateHeader), errorDescriptionMatch = /error_description=\"(.*?)\"/.exec(authenticateHeader);\n        hueError = new HueError_1.HueError({\n            type: response.status,\n            message: (errorMatch ? errorMatch[1] : response.data) || 'Error',\n            description: errorDescriptionMatch ? errorDescriptionMatch[1] : undefined,\n            address: (_a = response.config) === null || _a === void 0 ? void 0 : _a.url,\n        });\n    }\n    else {\n        hueError = new HueError_1.HueError({\n            type: response.status,\n            message: response.data || 'Error',\n            address: (_b = response.config) === null || _b === void 0 ? void 0 : _b.url,\n        });\n    }\n    return new ApiError_1.ApiError(hueError);\n}\n"]},"metadata":{},"sourceType":"script"}