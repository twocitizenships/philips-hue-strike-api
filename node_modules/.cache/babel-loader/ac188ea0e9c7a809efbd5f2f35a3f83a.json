{"ast":null,"code":"import { BaseType } from './BaseType';\nimport { isValueDefined } from './BaseType';\nexport class ObjectType extends BaseType {\n  constructor(config) {\n    super({ ...config,\n      type: 'object'\n    });\n    this.types = config.types;\n\n    if (!isValueDefined(config.types)) {\n      this.childRequiredKeys = [];\n    } else {\n      const childRequiredKeys = []; // @ts-ignore\n\n      config.types.forEach(type => {\n        if (!type.optional) {\n          childRequiredKeys.push(type.name);\n        }\n      });\n      this.childRequiredKeys = childRequiredKeys;\n    }\n  }\n\n  _convertToType(val) {\n    const result = this._getObject(val);\n\n    this._validateRequiredKeys(result);\n\n    if (Object.keys(result).length === 0) {\n      if (this.optional) {\n        return null;\n      } else {\n        throw new TypeError(`Empty object created from data provided, but the object is not optional`);\n      }\n    }\n\n    return result;\n  }\n\n  _getObject(val) {\n    // We have a free form object type\n    if (!this.types) {\n      return Object.assign({}, val);\n    }\n\n    const result = {}; // Build the object based off the definitions for the keys\n\n    this.types.forEach(typeAttribute => {\n      const name = typeAttribute.name,\n            typeValue = typeAttribute.getValue(val[name]);\n\n      if (isValueDefined(typeValue)) {\n        result[name] = typeValue;\n      }\n    });\n    return result;\n  }\n\n  _validateRequiredKeys(result) {\n    if (this.childRequiredKeys.length > 0) {\n      const valueKeys = Object.keys(result);\n      this.childRequiredKeys.forEach(requiredKey => {\n        if (valueKeys.indexOf(requiredKey) === -1) {\n          throw new TypeError(`Required key '${requiredKey}' is missing from the object`);\n        }\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/types/ObjectType.js"],"names":["BaseType","isValueDefined","ObjectType","constructor","config","type","types","childRequiredKeys","forEach","optional","push","name","_convertToType","val","result","_getObject","_validateRequiredKeys","Object","keys","length","TypeError","assign","typeAttribute","typeValue","getValue","valueKeys","requiredKey","indexOf"],"mappings":"AAAA,SAASA,QAAT,QAAyB,YAAzB;AACA,SAASC,cAAT,QAA+B,YAA/B;AACA,OAAO,MAAMC,UAAN,SAAyBF,QAAzB,CAAkC;AACrCG,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,UAAM,EAAE,GAAGA,MAAL;AAAaC,MAAAA,IAAI,EAAE;AAAnB,KAAN;AACA,SAAKC,KAAL,GAAaF,MAAM,CAACE,KAApB;;AACA,QAAI,CAACL,cAAc,CAACG,MAAM,CAACE,KAAR,CAAnB,EAAmC;AAC/B,WAAKC,iBAAL,GAAyB,EAAzB;AACH,KAFD,MAGK;AACD,YAAMA,iBAAiB,GAAG,EAA1B,CADC,CAED;;AACAH,MAAAA,MAAM,CAACE,KAAP,CAAaE,OAAb,CAAqBH,IAAI,IAAI;AACzB,YAAI,CAACA,IAAI,CAACI,QAAV,EAAoB;AAChBF,UAAAA,iBAAiB,CAACG,IAAlB,CAAuBL,IAAI,CAACM,IAA5B;AACH;AACJ,OAJD;AAKA,WAAKJ,iBAAL,GAAyBA,iBAAzB;AACH;AACJ;;AACDK,EAAAA,cAAc,CAACC,GAAD,EAAM;AAChB,UAAMC,MAAM,GAAG,KAAKC,UAAL,CAAgBF,GAAhB,CAAf;;AACA,SAAKG,qBAAL,CAA2BF,MAA3B;;AACA,QAAIG,MAAM,CAACC,IAAP,CAAYJ,MAAZ,EAAoBK,MAApB,KAA+B,CAAnC,EAAsC;AAClC,UAAI,KAAKV,QAAT,EAAmB;AACf,eAAO,IAAP;AACH,OAFD,MAGK;AACD,cAAM,IAAIW,SAAJ,CAAe,yEAAf,CAAN;AACH;AACJ;;AACD,WAAON,MAAP;AACH;;AACDC,EAAAA,UAAU,CAACF,GAAD,EAAM;AACZ;AACA,QAAI,CAAC,KAAKP,KAAV,EAAiB;AACb,aAAOW,MAAM,CAACI,MAAP,CAAc,EAAd,EAAkBR,GAAlB,CAAP;AACH;;AACD,UAAMC,MAAM,GAAG,EAAf,CALY,CAMZ;;AACA,SAAKR,KAAL,CAAWE,OAAX,CAAmBc,aAAa,IAAI;AAChC,YAAMX,IAAI,GAAGW,aAAa,CAACX,IAA3B;AAAA,YAAiCY,SAAS,GAAGD,aAAa,CAACE,QAAd,CAAuBX,GAAG,CAACF,IAAD,CAA1B,CAA7C;;AACA,UAAIV,cAAc,CAACsB,SAAD,CAAlB,EAA+B;AAC3BT,QAAAA,MAAM,CAACH,IAAD,CAAN,GAAeY,SAAf;AACH;AACJ,KALD;AAMA,WAAOT,MAAP;AACH;;AACDE,EAAAA,qBAAqB,CAACF,MAAD,EAAS;AAC1B,QAAI,KAAKP,iBAAL,CAAuBY,MAAvB,GAAgC,CAApC,EAAuC;AACnC,YAAMM,SAAS,GAAGR,MAAM,CAACC,IAAP,CAAYJ,MAAZ,CAAlB;AACA,WAAKP,iBAAL,CAAuBC,OAAvB,CAA+BkB,WAAW,IAAI;AAC1C,YAAID,SAAS,CAACE,OAAV,CAAkBD,WAAlB,MAAmC,CAAC,CAAxC,EAA2C;AACvC,gBAAM,IAAIN,SAAJ,CAAe,iBAAgBM,WAAY,8BAA3C,CAAN;AACH;AACJ,OAJD;AAKH;AACJ;;AAvDoC","sourcesContent":["import { BaseType } from './BaseType';\nimport { isValueDefined } from './BaseType';\nexport class ObjectType extends BaseType {\n    constructor(config) {\n        super({ ...config, type: 'object' });\n        this.types = config.types;\n        if (!isValueDefined(config.types)) {\n            this.childRequiredKeys = [];\n        }\n        else {\n            const childRequiredKeys = [];\n            // @ts-ignore\n            config.types.forEach(type => {\n                if (!type.optional) {\n                    childRequiredKeys.push(type.name);\n                }\n            });\n            this.childRequiredKeys = childRequiredKeys;\n        }\n    }\n    _convertToType(val) {\n        const result = this._getObject(val);\n        this._validateRequiredKeys(result);\n        if (Object.keys(result).length === 0) {\n            if (this.optional) {\n                return null;\n            }\n            else {\n                throw new TypeError(`Empty object created from data provided, but the object is not optional`);\n            }\n        }\n        return result;\n    }\n    _getObject(val) {\n        // We have a free form object type\n        if (!this.types) {\n            return Object.assign({}, val);\n        }\n        const result = {};\n        // Build the object based off the definitions for the keys\n        this.types.forEach(typeAttribute => {\n            const name = typeAttribute.name, typeValue = typeAttribute.getValue(val[name]);\n            if (isValueDefined(typeValue)) {\n                result[name] = typeValue;\n            }\n        });\n        return result;\n    }\n    _validateRequiredKeys(result) {\n        if (this.childRequiredKeys.length > 0) {\n            const valueKeys = Object.keys(result);\n            this.childRequiredKeys.forEach(requiredKey => {\n                if (valueKeys.indexOf(requiredKey) === -1) {\n                    throw new TypeError(`Required key '${requiredKey}' is missing from the object`);\n                }\n            });\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}