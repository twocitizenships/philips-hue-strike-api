{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteApi = void 0;\n\nconst httpClient = __importStar(require(\"./HttpClientFetch\"));\n\nconst ApiError_1 = require(\"../../ApiError\");\n\nconst OAuthTokens_1 = require(\"./OAuthTokens\");\n\nconst util_1 = require(\"../../util\");\n\nconst crypto_1 = require(\"crypto\"); // This class is a bit different to the other endpoints currently as they operate in a digest challenge for the most\n// part and also operate off a different base url compared with the local/remote endpoints that make up the rest of the\n// bridge API commands.\n\n\nclass RemoteApi {\n  constructor(clientId, clientSecret) {\n    this._config = {\n      clientId: clientId,\n      clientSecret: clientSecret,\n      baseUrl: new URL('https://api.meethue.com')\n    };\n    this._tokens = new OAuthTokens_1.OAuthTokens();\n  }\n\n  get clientId() {\n    return this._config.clientId;\n  }\n\n  get clientSecret() {\n    return this._config.clientSecret;\n  }\n\n  get baseUrl() {\n    return this._config.baseUrl.href;\n  }\n\n  get accessToken() {\n    return this._tokens.accessTokenValue;\n  }\n\n  get accessTokenExpiry() {\n    return this._tokens.accessTokenExpiresAt;\n  }\n\n  get refreshToken() {\n    return this._tokens.refreshTokenValue;\n  }\n\n  get refreshTokenExpiry() {\n    return this._tokens.refreshTokenExpiresAt;\n  }\n\n  setAccessToken(token, expiry) {\n    this._tokens._setAccessToken(token, expiry);\n\n    return this;\n  }\n\n  setRefreshToken(token, expiry) {\n    this._tokens._setRefreshToken(token, expiry);\n\n    return this;\n  }\n  /**\n   * Builds the digest response to pass to the remote API for the provided request details.\n   */\n\n\n  getDigestResponse(realm, nonce, method, path) {\n    const clientId = this.clientId,\n          clientSecret = this.clientSecret,\n          hashOne = (0, crypto_1.createHash)('md5').update(`${clientId}:${realm}:${clientSecret}`).digest('hex'),\n          hashTwo = (0, crypto_1.createHash)('md5').update(`${method.toUpperCase()}:${path}`).digest('hex'),\n          hash = (0, crypto_1.createHash)('md5').update(`${hashOne}:${nonce}:${hashTwo}`).digest('hex');\n\n    if (!clientId) {\n      throw new ApiError_1.ApiError('clientId has not been provided, unable to build a digest response');\n    }\n\n    if (!clientSecret) {\n      throw new ApiError_1.ApiError('clientSecret has not been provided, unable to build a digest response');\n    }\n\n    return hash;\n  }\n  /**\n   * Constructs the digest authorization header value from the provided details.\n   * @returns {string} The value to be used for the \"Authorization\" Header.\n   */\n\n\n  getAuthorizationHeaderDigest(realm, nonce, method, path) {\n    const clientId = this.clientId,\n          response = this.getDigestResponse(realm, nonce, method, path);\n    return `Digest username=\"${clientId}\", realm=\"${realm}\", nonce=\"${nonce}\", uri=\"${path}\", response=\"${response}\"`;\n  }\n  /**\n   * Constructs the basic authorization header value from the provided details.\n   *\n   * This is really poor for security, it is only included to complete the implementation of the APIs, you are strongly\n   * advised to use the digest authorization instead.\n      * @returns {string} The value to be used for the \"Authorization\" Header.\n   */\n\n\n  getAuthorizationHeaderBasic() {\n    const clientId = this.clientId,\n          clientSecret = this.clientSecret,\n          encoded = Buffer.from(`${clientId}:${clientSecret}`, 'ascii').toString('base64');\n    return `Basic ${encoded}`;\n  }\n  /**\n   * Exchanges the code for OAuth tokens.\n   * @param code The authorization code that is provided as part of the OAuth flow.\n   * @returns The OAuth Tokens obtained from the remote portal.\n   */\n\n\n  getToken(code) {\n    const self = this,\n          config = {\n      baseURL: self.baseUrl,\n      headers: {\n        'Accept': 'application/json'\n      },\n      responseType: 'json'\n    },\n          requestConfig = {\n      url: '/v2/oauth2/token',\n      method: 'POST',\n      params: {\n        code: code,\n        grant_type: 'authorization_code'\n      },\n      validateStatus: status => {\n        return status === 401;\n      }\n    },\n          start = Date.now();\n    const http = httpClient.create(config);\n    return http.request(requestConfig).then(res => {\n      return self._respondWithDigest(http, res, requestConfig);\n    }).then(res => {\n      if (res.status === 200) {\n        return self._processTokens(start, res.data);\n      } else {\n        throw new ApiError_1.ApiError(`Unexpected status code from getting token: ${res.status}`);\n      }\n    });\n  }\n  /**\n   * Refreshes the existing tokens by exchanging the current refresh token for new access and refresh tokens.\n   *\n   * After calling this the old tokens will no longer be valid. The new tokens obtained will be injected back into the\n   * API for future calls.\n   *\n   * You should ensure you save the new tokens in place of the previous ones that you used to establish the original\n   * remote connection.\n   *\n   * @param refreshToken The refresh token to exchange for new tokens.\n   * @returns Promise<Tokens> The new refreshed tokens.\n   */\n\n\n  refreshTokens(refreshToken) {\n    const self = this,\n          config = {\n      baseURL: self.baseUrl,\n      headers: {\n        'Accept': 'application/json'\n      },\n      responseType: 'json'\n    },\n          requestConfig = {\n      url: '/v2/oauth2/token',\n      method: 'POST',\n      params: {\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken\n      },\n      validateStatus: status => {\n        return status === 401;\n      }\n    },\n          start = Date.now();\n    const http = httpClient.create(config);\n    return http.request(requestConfig).then(res => {\n      return self._respondWithDigest(http, res, requestConfig);\n    }).then(res => {\n      if (res.status === 200) {\n        return self._processTokens(start, res.data);\n      } else {\n        throw new ApiError_1.ApiError(`Unexpected status code from refreshing tokens: ${res.status}`);\n      }\n    });\n  }\n  /**\n   * Creates a new remote user\n   * @param remoteBridgeId The id of the hue bridge in the remote portal, usually 0.\n   * @param deviceType The user device type identifier (this is shown to the end users on the remote access portal). If not specified will default to 'node-hue-api-remote'.\n   * @returns The new remote username.\n   */\n\n\n  createRemoteUsername(remoteBridgeId, deviceType) {\n    const self = this,\n          accessToken = self.accessToken;\n\n    if (Number.isNaN(Number.parseInt(remoteBridgeId))) {\n      // default to bridge id 0 (as this will be the case for most users\n      remoteBridgeId = 0;\n    }\n\n    if (!accessToken) {\n      throw new ApiError_1.ApiError('No current valid access token, you need to fetch an access token before continuing.');\n    }\n\n    const remoteApi = httpClient.create({\n      baseURL: self.baseUrl,\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': 'application/json'\n      }\n    }); // return remoteApi.put(`/bridge/${remoteBridgeId}/config`, {'linkbutton': true})\n\n    return remoteApi.request({\n      url: `/bridge/${remoteBridgeId}/config`,\n      method: 'PUT',\n      data: {\n        'linkbutton': true\n      },\n      json: true\n    }).then(res => {\n      if (!(0, util_1.wasSuccessful)(res.data)) {\n        throw new ApiError_1.ApiError(`Issue with activating remote link button, attempt was not successful: ${JSON.stringify(res.data)}`);\n      } // return remoteApi.post('/bridge', {devicetype: deviceType || 'node-hue-api-remote'})\n\n\n      return remoteApi.request({\n        url: '/bridge',\n        data: {\n          devicetype: deviceType || 'node-hue-api-remote'\n        },\n        method: 'POST',\n        json: true\n      }).then(res => {\n        if ((0, util_1.wasSuccessful)(res.data)) {\n          return res.data[0].success.username;\n        } else {\n          throw new ApiError_1.ApiError(`Failed to create a remote whitelist user: ${JSON.stringify(res.data)}`);\n        }\n      });\n    });\n  }\n\n  _respondWithDigest(http, res, requestConfig) {\n    // We need this information to build the digest Authorization header and get the nonce that we can use for the\n    // request that will be properly validated and issue us the authorization tokens.\n    const status = res.status;\n\n    if (status !== 401) {\n      throw new ApiError_1.ApiError(`Did not get the expected 401 response from the remote API that contains the www-authenticate details needed to proceed, got status ${status}`);\n    }\n\n    const wwwAuthenticate = getAuthenticationDetailsFromHeader(res.headers),\n          digestHeader = this.getAuthorizationHeaderDigest(wwwAuthenticate.realm, wwwAuthenticate.nonce, requestConfig.method, requestConfig.url);\n    requestConfig.headers = {\n      'Authorization': digestHeader\n    };\n    requestConfig.validateStatus = undefined;\n    return http.request(requestConfig);\n  }\n\n  _processTokens(start, data) {\n    this.setAccessToken(data.access_token, start + data.expires_in * 1000);\n    this.setRefreshToken(data.refresh_token, start + data.expires_in * 1000); // We have just set the tokens\n\n    return {\n      // @ts-ignore\n      accessToken: this._tokens.accessToken,\n      // @ts-ignore\n      refreshToken: this._tokens.refreshToken\n    };\n  }\n\n}\n\nexports.RemoteApi = RemoteApi;\n\nfunction getAuthenticationDetailsFromHeader(headers) {\n  // if (!response || !response.headers) {\n  //   throw new ApiError('Response object is missing headers property');\n  // }\n  if (!headers) {\n    throw new ApiError_1.ApiError('No headers provided');\n  }\n\n  if (!headers['www-authenticate']) {\n    throw new ApiError_1.ApiError('Response is missing the \"www-authenticate\" header');\n  }\n\n  const wwwAuthenticate = headers['www-authenticate'];\n  const realmResult = /realm=\"(.*?)\"/.exec(wwwAuthenticate);\n\n  if (!realmResult) {\n    throw new ApiError_1.ApiError(`Realm was not found in www-authenticate header '${wwwAuthenticate}'`);\n  }\n\n  const nonceResult = /nonce=\"(.*?)\"/.exec(wwwAuthenticate);\n\n  if (!nonceResult) {\n    throw new ApiError_1.ApiError(`Nonce was not found in www-authenitcate header '${wwwAuthenticate}'`);\n  }\n\n  return {\n    realm: realmResult[1],\n    nonce: nonceResult[1]\n  };\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/node-hue-api/dist/cjs/api/http/RemoteApi.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","RemoteApi","httpClient","require","ApiError_1","OAuthTokens_1","util_1","crypto_1","constructor","clientId","clientSecret","_config","baseUrl","URL","_tokens","OAuthTokens","href","accessToken","accessTokenValue","accessTokenExpiry","accessTokenExpiresAt","refreshToken","refreshTokenValue","refreshTokenExpiry","refreshTokenExpiresAt","setAccessToken","token","expiry","_setAccessToken","setRefreshToken","_setRefreshToken","getDigestResponse","realm","nonce","method","path","hashOne","createHash","update","digest","hashTwo","toUpperCase","hash","ApiError","getAuthorizationHeaderDigest","response","getAuthorizationHeaderBasic","encoded","Buffer","from","toString","getToken","code","self","config","baseURL","headers","responseType","requestConfig","url","params","grant_type","validateStatus","status","start","Date","now","http","request","then","res","_respondWithDigest","_processTokens","data","refreshTokens","refresh_token","createRemoteUsername","remoteBridgeId","deviceType","Number","isNaN","parseInt","remoteApi","Authorization","json","wasSuccessful","JSON","stringify","devicetype","success","username","wwwAuthenticate","getAuthenticationDetailsFromHeader","digestHeader","access_token","expires_in","realmResult","exec","nonceResult"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteApi = void 0;\nconst httpClient = __importStar(require(\"./HttpClientFetch\"));\nconst ApiError_1 = require(\"../../ApiError\");\nconst OAuthTokens_1 = require(\"./OAuthTokens\");\nconst util_1 = require(\"../../util\");\nconst crypto_1 = require(\"crypto\");\n// This class is a bit different to the other endpoints currently as they operate in a digest challenge for the most\n// part and also operate off a different base url compared with the local/remote endpoints that make up the rest of the\n// bridge API commands.\nclass RemoteApi {\n    constructor(clientId, clientSecret) {\n        this._config = {\n            clientId: clientId,\n            clientSecret: clientSecret,\n            baseUrl: new URL('https://api.meethue.com'),\n        };\n        this._tokens = new OAuthTokens_1.OAuthTokens();\n    }\n    get clientId() {\n        return this._config.clientId;\n    }\n    get clientSecret() {\n        return this._config.clientSecret;\n    }\n    get baseUrl() {\n        return this._config.baseUrl.href;\n    }\n    get accessToken() {\n        return this._tokens.accessTokenValue;\n    }\n    get accessTokenExpiry() {\n        return this._tokens.accessTokenExpiresAt;\n    }\n    get refreshToken() {\n        return this._tokens.refreshTokenValue;\n    }\n    get refreshTokenExpiry() {\n        return this._tokens.refreshTokenExpiresAt;\n    }\n    setAccessToken(token, expiry) {\n        this._tokens._setAccessToken(token, expiry);\n        return this;\n    }\n    setRefreshToken(token, expiry) {\n        this._tokens._setRefreshToken(token, expiry);\n        return this;\n    }\n    /**\n     * Builds the digest response to pass to the remote API for the provided request details.\n     */\n    getDigestResponse(realm, nonce, method, path) {\n        const clientId = this.clientId, clientSecret = this.clientSecret, hashOne = (0, crypto_1.createHash)('md5').update(`${clientId}:${realm}:${clientSecret}`).digest('hex'), hashTwo = (0, crypto_1.createHash)('md5').update(`${method.toUpperCase()}:${path}`).digest('hex'), hash = (0, crypto_1.createHash)('md5').update(`${hashOne}:${nonce}:${hashTwo}`).digest('hex');\n        if (!clientId) {\n            throw new ApiError_1.ApiError('clientId has not been provided, unable to build a digest response');\n        }\n        if (!clientSecret) {\n            throw new ApiError_1.ApiError('clientSecret has not been provided, unable to build a digest response');\n        }\n        return hash;\n    }\n    /**\n     * Constructs the digest authorization header value from the provided details.\n     * @returns {string} The value to be used for the \"Authorization\" Header.\n     */\n    getAuthorizationHeaderDigest(realm, nonce, method, path) {\n        const clientId = this.clientId, response = this.getDigestResponse(realm, nonce, method, path);\n        return `Digest username=\"${clientId}\", realm=\"${realm}\", nonce=\"${nonce}\", uri=\"${path}\", response=\"${response}\"`;\n    }\n    /**\n     * Constructs the basic authorization header value from the provided details.\n     *\n     * This is really poor for security, it is only included to complete the implementation of the APIs, you are strongly\n     * advised to use the digest authorization instead.\n  \n     * @returns {string} The value to be used for the \"Authorization\" Header.\n     */\n    getAuthorizationHeaderBasic() {\n        const clientId = this.clientId, clientSecret = this.clientSecret, encoded = Buffer.from(`${clientId}:${clientSecret}`, 'ascii').toString('base64');\n        return `Basic ${encoded}`;\n    }\n    /**\n     * Exchanges the code for OAuth tokens.\n     * @param code The authorization code that is provided as part of the OAuth flow.\n     * @returns The OAuth Tokens obtained from the remote portal.\n     */\n    getToken(code) {\n        const self = this, config = {\n            baseURL: self.baseUrl,\n            headers: {\n                'Accept': 'application/json'\n            },\n            responseType: 'json',\n        }, requestConfig = {\n            url: '/v2/oauth2/token',\n            method: 'POST',\n            params: {\n                code: code,\n                grant_type: 'authorization_code'\n            },\n            validateStatus: (status) => {\n                return status === 401;\n            }\n        }, start = Date.now();\n        const http = httpClient.create(config);\n        return http.request(requestConfig)\n            .then(res => {\n            return self._respondWithDigest(http, res, requestConfig);\n        })\n            .then(res => {\n            if (res.status === 200) {\n                return self._processTokens(start, res.data);\n            }\n            else {\n                throw new ApiError_1.ApiError(`Unexpected status code from getting token: ${res.status}`);\n            }\n        });\n    }\n    /**\n     * Refreshes the existing tokens by exchanging the current refresh token for new access and refresh tokens.\n     *\n     * After calling this the old tokens will no longer be valid. The new tokens obtained will be injected back into the\n     * API for future calls.\n     *\n     * You should ensure you save the new tokens in place of the previous ones that you used to establish the original\n     * remote connection.\n     *\n     * @param refreshToken The refresh token to exchange for new tokens.\n     * @returns Promise<Tokens> The new refreshed tokens.\n     */\n    refreshTokens(refreshToken) {\n        const self = this, config = {\n            baseURL: self.baseUrl,\n            headers: {\n                'Accept': 'application/json'\n            },\n            responseType: 'json',\n        }, requestConfig = {\n            url: '/v2/oauth2/token',\n            method: 'POST',\n            params: {\n                grant_type: 'refresh_token',\n                refresh_token: refreshToken\n            },\n            validateStatus: (status) => {\n                return status === 401;\n            }\n        }, start = Date.now();\n        const http = httpClient.create(config);\n        return http.request(requestConfig)\n            .then(res => {\n            return self._respondWithDigest(http, res, requestConfig);\n        })\n            .then(res => {\n            if (res.status === 200) {\n                return self._processTokens(start, res.data);\n            }\n            else {\n                throw new ApiError_1.ApiError(`Unexpected status code from refreshing tokens: ${res.status}`);\n            }\n        });\n    }\n    /**\n     * Creates a new remote user\n     * @param remoteBridgeId The id of the hue bridge in the remote portal, usually 0.\n     * @param deviceType The user device type identifier (this is shown to the end users on the remote access portal). If not specified will default to 'node-hue-api-remote'.\n     * @returns The new remote username.\n     */\n    createRemoteUsername(remoteBridgeId, deviceType) {\n        const self = this, accessToken = self.accessToken;\n        if (Number.isNaN(Number.parseInt(remoteBridgeId))) {\n            // default to bridge id 0 (as this will be the case for most users\n            remoteBridgeId = 0;\n        }\n        if (!accessToken) {\n            throw new ApiError_1.ApiError('No current valid access token, you need to fetch an access token before continuing.');\n        }\n        const remoteApi = httpClient.create({\n            baseURL: self.baseUrl,\n            headers: {\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json'\n            }\n        });\n        // return remoteApi.put(`/bridge/${remoteBridgeId}/config`, {'linkbutton': true})\n        return remoteApi.request({\n            url: `/bridge/${remoteBridgeId}/config`,\n            method: 'PUT',\n            data: { 'linkbutton': true },\n            json: true,\n        }).then(res => {\n            if (!(0, util_1.wasSuccessful)(res.data)) {\n                throw new ApiError_1.ApiError(`Issue with activating remote link button, attempt was not successful: ${JSON.stringify(res.data)}`);\n            }\n            // return remoteApi.post('/bridge', {devicetype: deviceType || 'node-hue-api-remote'})\n            return remoteApi.request({\n                url: '/bridge',\n                data: { devicetype: deviceType || 'node-hue-api-remote' },\n                method: 'POST',\n                json: true,\n            }).then(res => {\n                if ((0, util_1.wasSuccessful)(res.data)) {\n                    return res.data[0].success.username;\n                }\n                else {\n                    throw new ApiError_1.ApiError(`Failed to create a remote whitelist user: ${JSON.stringify(res.data)}`);\n                }\n            });\n        });\n    }\n    _respondWithDigest(http, res, requestConfig) {\n        // We need this information to build the digest Authorization header and get the nonce that we can use for the\n        // request that will be properly validated and issue us the authorization tokens.\n        const status = res.status;\n        if (status !== 401) {\n            throw new ApiError_1.ApiError(`Did not get the expected 401 response from the remote API that contains the www-authenticate details needed to proceed, got status ${status}`);\n        }\n        const wwwAuthenticate = getAuthenticationDetailsFromHeader(res.headers), digestHeader = this.getAuthorizationHeaderDigest(wwwAuthenticate.realm, wwwAuthenticate.nonce, requestConfig.method, requestConfig.url);\n        requestConfig.headers = {\n            'Authorization': digestHeader\n        };\n        requestConfig.validateStatus = undefined;\n        return http.request(requestConfig);\n    }\n    _processTokens(start, data) {\n        this.setAccessToken(data.access_token, start + (data.expires_in * 1000));\n        this.setRefreshToken(data.refresh_token, start + (data.expires_in * 1000));\n        // We have just set the tokens\n        return {\n            // @ts-ignore\n            accessToken: this._tokens.accessToken,\n            // @ts-ignore\n            refreshToken: this._tokens.refreshToken,\n        };\n    }\n}\nexports.RemoteApi = RemoteApi;\nfunction getAuthenticationDetailsFromHeader(headers) {\n    // if (!response || !response.headers) {\n    //   throw new ApiError('Response object is missing headers property');\n    // }\n    if (!headers) {\n        throw new ApiError_1.ApiError('No headers provided');\n    }\n    if (!headers['www-authenticate']) {\n        throw new ApiError_1.ApiError('Response is missing the \"www-authenticate\" header');\n    }\n    const wwwAuthenticate = headers['www-authenticate'];\n    const realmResult = /realm=\"(.*?)\"/.exec(wwwAuthenticate);\n    if (!realmResult) {\n        throw new ApiError_1.ApiError(`Realm was not found in www-authenticate header '${wwwAuthenticate}'`);\n    }\n    const nonceResult = /nonce=\"(.*?)\"/.exec(wwwAuthenticate);\n    if (!nonceResult) {\n        throw new ApiError_1.ApiError(`Nonce was not found in www-authenitcate header '${wwwAuthenticate}'`);\n    }\n    return {\n        realm: realmResult[1],\n        nonce: nonceResult[1],\n    };\n}\n"]},"metadata":{},"sourceType":"script"}