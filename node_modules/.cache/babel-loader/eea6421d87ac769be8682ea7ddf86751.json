{"ast":null,"code":"import { BaseType } from './BaseType';\nimport { isValueDefined } from './BaseType';\nexport class ListType extends BaseType {\n  constructor(config) {\n    // @ts-ignore\n    super({ ...config,\n      type: 'list'\n    });\n    this.minEntries = config.minEntries;\n    this.maxEntries = config.maxEntries;\n    this.entryType = config.entryType;\n  }\n\n  getValue(val) {\n    // @ts-ignore\n    const listValues = super.getValue.apply(this, Array.from(arguments));\n\n    if (!isValueDefined(listValues)) {\n      // Validate the min entries requirement is met\n      if (this.minEntries === 0) {\n        return listValues;\n      } else {\n        throw new TypeError(`BaseType ${this.name}, minEntries requirement not satisfied, required ${this.minEntries}, but have null object`);\n      }\n    } // Value is defined, so validate it according to specification\n    // @ts-ignore\n\n\n    const length = listValues.length;\n\n    if (length < this.minEntries) {\n      throw new TypeError(`The number of entries for the list, \"${length}\" is less than required minimum of ${this.minEntries}`);\n    }\n\n    if (this.maxEntries && length > this.maxEntries) {\n      throw new TypeError(`The number of entries for the list, ${length}, is greater than required maximum of ${this.maxEntries}`);\n    }\n\n    return listValues;\n  }\n\n  _convertToType(val) {\n    if (!isValueDefined(val)) {\n      return null;\n    }\n\n    const result = [],\n          type = this.entryType;\n\n    if (Array.isArray(val)) {\n      val.forEach(value => {\n        result.push(type.getValue(value));\n      });\n    } else {\n      result.push(type.getValue(val));\n    } // @ts-ignore\n\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/types/ListType.js"],"names":["BaseType","isValueDefined","ListType","constructor","config","type","minEntries","maxEntries","entryType","getValue","val","listValues","apply","Array","from","arguments","TypeError","name","length","_convertToType","result","isArray","forEach","value","push"],"mappings":"AAAA,SAASA,QAAT,QAAyB,YAAzB;AACA,SAASC,cAAT,QAA+B,YAA/B;AACA,OAAO,MAAMC,QAAN,SAAuBF,QAAvB,CAAgC;AACnCG,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB;AACA,UAAM,EAAE,GAAGA,MAAL;AAAaC,MAAAA,IAAI,EAAE;AAAnB,KAAN;AACA,SAAKC,UAAL,GAAkBF,MAAM,CAACE,UAAzB;AACA,SAAKC,UAAL,GAAkBH,MAAM,CAACG,UAAzB;AACA,SAAKC,SAAL,GAAiBJ,MAAM,CAACI,SAAxB;AACH;;AACDC,EAAAA,QAAQ,CAACC,GAAD,EAAM;AACV;AACA,UAAMC,UAAU,GAAG,MAAMF,QAAN,CAAeG,KAAf,CAAqB,IAArB,EAA2BC,KAAK,CAACC,IAAN,CAAWC,SAAX,CAA3B,CAAnB;;AACA,QAAI,CAACd,cAAc,CAACU,UAAD,CAAnB,EAAiC;AAC7B;AACA,UAAI,KAAKL,UAAL,KAAoB,CAAxB,EAA2B;AACvB,eAAOK,UAAP;AACH,OAFD,MAGK;AACD,cAAM,IAAIK,SAAJ,CAAe,YAAW,KAAKC,IAAK,oDAAmD,KAAKX,UAAW,wBAAvG,CAAN;AACH;AACJ,KAXS,CAYV;AACA;;;AACA,UAAMY,MAAM,GAAGP,UAAU,CAACO,MAA1B;;AACA,QAAIA,MAAM,GAAG,KAAKZ,UAAlB,EAA8B;AAC1B,YAAM,IAAIU,SAAJ,CAAe,wCAAuCE,MAAO,sCAAqC,KAAKZ,UAAW,EAAlH,CAAN;AACH;;AACD,QAAI,KAAKC,UAAL,IAAmBW,MAAM,GAAG,KAAKX,UAArC,EAAiD;AAC7C,YAAM,IAAIS,SAAJ,CAAe,uCAAsCE,MAAO,yCAAwC,KAAKX,UAAW,EAApH,CAAN;AACH;;AACD,WAAOI,UAAP;AACH;;AAEDQ,EAAAA,cAAc,CAACT,GAAD,EAAM;AAChB,QAAI,CAACT,cAAc,CAACS,GAAD,CAAnB,EAA0B;AACtB,aAAO,IAAP;AACH;;AACD,UAAMU,MAAM,GAAG,EAAf;AAAA,UAAmBf,IAAI,GAAG,KAAKG,SAA/B;;AACA,QAAIK,KAAK,CAACQ,OAAN,CAAcX,GAAd,CAAJ,EAAwB;AACpBA,MAAAA,GAAG,CAACY,OAAJ,CAAYC,KAAK,IAAI;AACjBH,QAAAA,MAAM,CAACI,IAAP,CAAYnB,IAAI,CAACI,QAAL,CAAcc,KAAd,CAAZ;AACH,OAFD;AAGH,KAJD,MAKK;AACDH,MAAAA,MAAM,CAACI,IAAP,CAAYnB,IAAI,CAACI,QAAL,CAAcC,GAAd,CAAZ;AACH,KAZe,CAahB;;;AACA,WAAOU,MAAP;AACH;;AA/CkC","sourcesContent":["import { BaseType } from './BaseType';\nimport { isValueDefined } from './BaseType';\nexport class ListType extends BaseType {\n    constructor(config) {\n        // @ts-ignore\n        super({ ...config, type: 'list' });\n        this.minEntries = config.minEntries;\n        this.maxEntries = config.maxEntries;\n        this.entryType = config.entryType;\n    }\n    getValue(val) {\n        // @ts-ignore\n        const listValues = super.getValue.apply(this, Array.from(arguments));\n        if (!isValueDefined(listValues)) {\n            // Validate the min entries requirement is met\n            if (this.minEntries === 0) {\n                return listValues;\n            }\n            else {\n                throw new TypeError(`BaseType ${this.name}, minEntries requirement not satisfied, required ${this.minEntries}, but have null object`);\n            }\n        }\n        // Value is defined, so validate it according to specification\n        // @ts-ignore\n        const length = listValues.length;\n        if (length < this.minEntries) {\n            throw new TypeError(`The number of entries for the list, \"${length}\" is less than required minimum of ${this.minEntries}`);\n        }\n        if (this.maxEntries && length > this.maxEntries) {\n            throw new TypeError(`The number of entries for the list, ${length}, is greater than required maximum of ${this.maxEntries}`);\n        }\n        return listValues;\n    }\n    ;\n    _convertToType(val) {\n        if (!isValueDefined(val)) {\n            return null;\n        }\n        const result = [], type = this.entryType;\n        if (Array.isArray(val)) {\n            val.forEach(value => {\n                result.push(type.getValue(value));\n            });\n        }\n        else {\n            result.push(type.getValue(val));\n        }\n        // @ts-ignore\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}