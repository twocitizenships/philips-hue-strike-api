{"ast":null,"code":"import { HueBridgeModelError } from '../../../HueBridgeModelError';\nimport { getOperator } from './operators';\nimport { RuleCondition } from './RuleCondition';\nexport class SensorCondition {\n  constructor(sensor) {\n    this._sensor = sensor;\n    this._sensorStateAttribute = null;\n    this._operator = null;\n    this._value = null;\n  }\n\n  when(attribute) {\n    const self = this;\n    validateSensorAttribute(this._sensor, attribute);\n    this._sensorStateAttribute = attribute;\n    return new SelectOperator(self);\n  }\n\n  get sensor() {\n    return this._sensor;\n  }\n\n  get sensorStateAttribute() {\n    return this._sensorStateAttribute;\n  }\n\n  get operator() {\n    return this._operator;\n  }\n\n  getRuleCondition() {\n    validateState(this);\n    const data = {\n      address: `/sensors/${this.sensor.id}/state/${this.sensorStateAttribute}`,\n      operator: this.operator,\n      value: this._value\n    }; // @ts-ignore\n\n    return new RuleCondition(data);\n  } //TODO\n\n\n  _setOperator(value) {\n    this._operator = getOperator(value);\n  } //TODO\n\n\n  _setRequiredValue(value) {\n    if (value === null || value === undefined) {\n      throw new HueBridgeModelError('A value is required when using this operator');\n    }\n\n    this._value = value;\n  }\n\n}\n;\n\nfunction validateState(condition) {\n  let message = null;\n\n  if (!condition.sensor) {\n    message = 'a sensor is required';\n  } else if (!condition.sensorStateAttribute) {\n    message = 'a state of the sensor is required';\n  } else if (!condition.operator) {\n    message = 'an operator for the sensor state value is required';\n  } //TODO some operators require a value, others do not, might need to validate that here too, should have a function on the operator to check is a value is required\n\n\n  if (message) {\n    throw new HueBridgeModelError(`Invalid Condition, ${message}`);\n  }\n}\n\nfunction validateSensorAttribute(sensor, attributeName) {\n  const allAttributes = sensor.getStateAttributeNames();\n\n  if (allAttributes.indexOf(attributeName) > -1) {\n    return attributeName;\n  } else {\n    throw new HueBridgeModelError(`Attribute '${attributeName}' not found in sensor attributes, ${JSON.stringify(allAttributes)}`);\n  }\n}\n\nclass SelectOperator {\n  constructor(sensorCondition) {\n    this._sensorCondition = sensorCondition;\n  }\n\n  equals(val) {\n    const sensorCondition = this._sensorCondition;\n\n    sensorCondition._setOperator('eq'); // bool or int\n\n\n    sensorCondition._setRequiredValue(val);\n\n    return sensorCondition;\n  }\n\n  greaterThan(val) {\n    const sensorCondition = this._sensorCondition;\n\n    sensorCondition._setOperator('gt'); // int\n\n\n    sensorCondition._setRequiredValue(val);\n\n    return sensorCondition;\n  }\n\n  lessThan(val) {\n    const sensorCondition = this._sensorCondition;\n\n    sensorCondition._setOperator('lt'); // int\n\n\n    sensorCondition._setRequiredValue(val);\n\n    return sensorCondition;\n  }\n\n  changed() {\n    const sensorCondition = this._sensorCondition;\n\n    sensorCondition._setOperator('dx');\n\n    return sensorCondition;\n  }\n\n  changedDelayed(interval) {\n    const sensorCondition = this._sensorCondition;\n\n    sensorCondition._setOperator('ddx');\n\n    sensorCondition._setRequiredValue(interval);\n\n    return sensorCondition;\n  }\n\n  stable(interval) {\n    const sensorCondition = this._sensorCondition;\n\n    sensorCondition._setOperator('stable');\n\n    sensorCondition._setRequiredValue(interval);\n\n    return sensorCondition;\n  }\n\n  notStable(interval) {\n    const sensorCondition = this._sensorCondition;\n\n    sensorCondition._setOperator('not stable');\n\n    sensorCondition._setRequiredValue(interval);\n\n    return sensorCondition;\n  }\n\n  in(interval) {\n    const sensorCondition = this._sensorCondition; //start time, only valid for /config/localtime\n\n    sensorCondition._setOperator('in');\n\n    sensorCondition._setRequiredValue(interval);\n\n    return sensorCondition;\n  }\n\n  notIn(interval) {\n    const sensorCondition = this._sensorCondition; // end time, only valid for /config/localtime\n\n    sensorCondition._setOperator('not in');\n\n    sensorCondition._setRequiredValue(interval);\n\n    return sensorCondition;\n  }\n\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/model/rules/conditions/SensorCondition.js"],"names":["HueBridgeModelError","getOperator","RuleCondition","SensorCondition","constructor","sensor","_sensor","_sensorStateAttribute","_operator","_value","when","attribute","self","validateSensorAttribute","SelectOperator","sensorStateAttribute","operator","getRuleCondition","validateState","data","address","id","value","_setOperator","_setRequiredValue","undefined","condition","message","attributeName","allAttributes","getStateAttributeNames","indexOf","JSON","stringify","sensorCondition","_sensorCondition","equals","val","greaterThan","lessThan","changed","changedDelayed","interval","stable","notStable","in","notIn"],"mappings":"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","sourcesContent":["import { HueBridgeModelError } from '../../../HueBridgeModelError';\nimport { getOperator } from './operators';\nimport { RuleCondition } from './RuleCondition';\nexport class SensorCondition {\n    constructor(sensor) {\n        this._sensor = sensor;\n        this._sensorStateAttribute = null;\n        this._operator = null;\n        this._value = null;\n    }\n    when(attribute) {\n        const self = this;\n        validateSensorAttribute(this._sensor, attribute);\n        this._sensorStateAttribute = attribute;\n        return new SelectOperator(self);\n    }\n    get sensor() {\n        return this._sensor;\n    }\n    get sensorStateAttribute() {\n        return this._sensorStateAttribute;\n    }\n    get operator() {\n        return this._operator;\n    }\n    getRuleCondition() {\n        validateState(this);\n        const data = {\n            address: `/sensors/${this.sensor.id}/state/${this.sensorStateAttribute}`,\n            operator: this.operator,\n            value: this._value\n        };\n        // @ts-ignore\n        return new RuleCondition(data);\n    }\n    //TODO\n    _setOperator(value) {\n        this._operator = getOperator(value);\n    }\n    //TODO\n    _setRequiredValue(value) {\n        if (value === null || value === undefined) {\n            throw new HueBridgeModelError('A value is required when using this operator');\n        }\n        this._value = value;\n    }\n}\n;\nfunction validateState(condition) {\n    let message = null;\n    if (!condition.sensor) {\n        message = 'a sensor is required';\n    }\n    else if (!condition.sensorStateAttribute) {\n        message = 'a state of the sensor is required';\n    }\n    else if (!condition.operator) {\n        message = 'an operator for the sensor state value is required';\n    }\n    //TODO some operators require a value, others do not, might need to validate that here too, should have a function on the operator to check is a value is required\n    if (message) {\n        throw new HueBridgeModelError(`Invalid Condition, ${message}`);\n    }\n}\nfunction validateSensorAttribute(sensor, attributeName) {\n    const allAttributes = sensor.getStateAttributeNames();\n    if (allAttributes.indexOf(attributeName) > -1) {\n        return attributeName;\n    }\n    else {\n        throw new HueBridgeModelError(`Attribute '${attributeName}' not found in sensor attributes, ${JSON.stringify(allAttributes)}`);\n    }\n}\nclass SelectOperator {\n    constructor(sensorCondition) {\n        this._sensorCondition = sensorCondition;\n    }\n    equals(val) {\n        const sensorCondition = this._sensorCondition;\n        sensorCondition._setOperator('eq');\n        // bool or int\n        sensorCondition._setRequiredValue(val);\n        return sensorCondition;\n    }\n    greaterThan(val) {\n        const sensorCondition = this._sensorCondition;\n        sensorCondition._setOperator('gt');\n        // int\n        sensorCondition._setRequiredValue(val);\n        return sensorCondition;\n    }\n    lessThan(val) {\n        const sensorCondition = this._sensorCondition;\n        sensorCondition._setOperator('lt');\n        // int\n        sensorCondition._setRequiredValue(val);\n        return sensorCondition;\n    }\n    changed() {\n        const sensorCondition = this._sensorCondition;\n        sensorCondition._setOperator('dx');\n        return sensorCondition;\n    }\n    changedDelayed(interval) {\n        const sensorCondition = this._sensorCondition;\n        sensorCondition._setOperator('ddx');\n        sensorCondition._setRequiredValue(interval);\n        return sensorCondition;\n    }\n    stable(interval) {\n        const sensorCondition = this._sensorCondition;\n        sensorCondition._setOperator('stable');\n        sensorCondition._setRequiredValue(interval);\n        return sensorCondition;\n    }\n    notStable(interval) {\n        const sensorCondition = this._sensorCondition;\n        sensorCondition._setOperator('not stable');\n        sensorCondition._setRequiredValue(interval);\n        return sensorCondition;\n    }\n    in(interval) {\n        const sensorCondition = this._sensorCondition;\n        //start time, only valid for /config/localtime\n        sensorCondition._setOperator('in');\n        sensorCondition._setRequiredValue(interval);\n        return sensorCondition;\n    }\n    notIn(interval) {\n        const sensorCondition = this._sensorCondition;\n        // end time, only valid for /config/localtime\n        sensorCondition._setOperator('not in');\n        sensorCondition._setRequiredValue(interval);\n        return sensorCondition;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}