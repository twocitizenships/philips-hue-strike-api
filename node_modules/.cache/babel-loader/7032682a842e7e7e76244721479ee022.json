{"ast":null,"code":"\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar BottleneckError, LocalDatastore, parser;\nparser = require(\"./parser\");\nBottleneckError = require(\"./BottleneckError\");\nLocalDatastore = class LocalDatastore {\n  constructor(instance, storeOptions, storeInstanceOptions) {\n    this.instance = instance;\n    this.storeOptions = storeOptions;\n    this.clientId = this.instance._randomIndex();\n    parser.load(storeInstanceOptions, storeInstanceOptions, this);\n    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n    this._running = 0;\n    this._done = 0;\n    this._unblockTime = 0;\n    this.ready = this.Promise.resolve();\n    this.clients = {};\n\n    this._startHeartbeat();\n  }\n\n  _startHeartbeat() {\n    var base;\n\n    if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {\n      return typeof (base = this.heartbeat = setInterval(() => {\n        var amount, incr, maximum, now, reservoir;\n        now = Date.now();\n\n        if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\n          this._lastReservoirRefresh = now;\n          this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\n\n          this.instance._drainAll(this.computeCapacity());\n        }\n\n        if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\n          var _this$storeOptions = this.storeOptions;\n          amount = _this$storeOptions.reservoirIncreaseAmount;\n          maximum = _this$storeOptions.reservoirIncreaseMaximum;\n          reservoir = _this$storeOptions.reservoir;\n          this._lastReservoirIncrease = now;\n          incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n\n          if (incr > 0) {\n            this.storeOptions.reservoir += incr;\n            return this.instance._drainAll(this.computeCapacity());\n          }\n        }\n      }, this.heartbeatInterval)).unref === \"function\" ? base.unref() : void 0;\n    } else {\n      return clearInterval(this.heartbeat);\n    }\n  }\n\n  __publish__(message) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.yieldLoop();\n      return _this.instance.Events.trigger(\"message\", message.toString());\n    })();\n  }\n\n  __disconnect__(flush) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.yieldLoop();\n      clearInterval(_this2.heartbeat);\n      return _this2.Promise.resolve();\n    })();\n  }\n\n  yieldLoop() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return new this.Promise(function (resolve, reject) {\n      return setTimeout(resolve, t);\n    });\n  }\n\n  computePenalty() {\n    var ref;\n    return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;\n  }\n\n  __updateSettings__(options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.yieldLoop();\n      parser.overwrite(options, options, _this3.storeOptions);\n\n      _this3._startHeartbeat();\n\n      _this3.instance._drainAll(_this3.computeCapacity());\n\n      return true;\n    })();\n  }\n\n  __running__() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.yieldLoop();\n      return _this4._running;\n    })();\n  }\n\n  __queued__() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.yieldLoop();\n      return _this5.instance.queued();\n    })();\n  }\n\n  __done__() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6.yieldLoop();\n      return _this6._done;\n    })();\n  }\n\n  __groupCheck__(time) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this7.yieldLoop();\n      return _this7._nextRequest + _this7.timeout < time;\n    })();\n  }\n\n  computeCapacity() {\n    var maxConcurrent, reservoir;\n    var _this$storeOptions2 = this.storeOptions;\n    maxConcurrent = _this$storeOptions2.maxConcurrent;\n    reservoir = _this$storeOptions2.reservoir;\n\n    if (maxConcurrent != null && reservoir != null) {\n      return Math.min(maxConcurrent - this._running, reservoir);\n    } else if (maxConcurrent != null) {\n      return maxConcurrent - this._running;\n    } else if (reservoir != null) {\n      return reservoir;\n    } else {\n      return null;\n    }\n  }\n\n  conditionsCheck(weight) {\n    var capacity;\n    capacity = this.computeCapacity();\n    return capacity == null || weight <= capacity;\n  }\n\n  __incrementReservoir__(incr) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var reservoir;\n      yield _this8.yieldLoop();\n      reservoir = _this8.storeOptions.reservoir += incr;\n\n      _this8.instance._drainAll(_this8.computeCapacity());\n\n      return reservoir;\n    })();\n  }\n\n  __currentReservoir__() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this9.yieldLoop();\n      return _this9.storeOptions.reservoir;\n    })();\n  }\n\n  isBlocked(now) {\n    return this._unblockTime >= now;\n  }\n\n  check(weight, now) {\n    return this.conditionsCheck(weight) && this._nextRequest - now <= 0;\n  }\n\n  __check__(weight) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      var now;\n      yield _this10.yieldLoop();\n      now = Date.now();\n      return _this10.check(weight, now);\n    })();\n  }\n\n  __register__(index, weight, expiration) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      var now, wait;\n      yield _this11.yieldLoop();\n      now = Date.now();\n\n      if (_this11.conditionsCheck(weight)) {\n        _this11._running += weight;\n\n        if (_this11.storeOptions.reservoir != null) {\n          _this11.storeOptions.reservoir -= weight;\n        }\n\n        wait = Math.max(_this11._nextRequest - now, 0);\n        _this11._nextRequest = now + wait + _this11.storeOptions.minTime;\n        return {\n          success: true,\n          wait,\n          reservoir: _this11.storeOptions.reservoir\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    })();\n  }\n\n  strategyIsBlock() {\n    return this.storeOptions.strategy === 3;\n  }\n\n  __submit__(queueLength, weight) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      var blocked, now, reachedHWM;\n      yield _this12.yieldLoop();\n\n      if (_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent) {\n        throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this12.storeOptions.maxConcurrent}`);\n      }\n\n      now = Date.now();\n      reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);\n      blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));\n\n      if (blocked) {\n        _this12._unblockTime = now + _this12.computePenalty();\n        _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;\n\n        _this12.instance._dropAllQueued();\n      }\n\n      return {\n        reachedHWM,\n        blocked,\n        strategy: _this12.storeOptions.strategy\n      };\n    })();\n  }\n\n  __free__(index, weight) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this13.yieldLoop();\n      _this13._running -= weight;\n      _this13._done += weight;\n\n      _this13.instance._drainAll(_this13.computeCapacity());\n\n      return {\n        running: _this13._running\n      };\n    })();\n  }\n\n};\nmodule.exports = LocalDatastore;","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/bottleneck/lib/LocalDatastore.js"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","BottleneckError","LocalDatastore","parser","require","constructor","instance","storeOptions","storeInstanceOptions","clientId","_randomIndex","load","_nextRequest","_lastReservoirRefresh","_lastReservoirIncrease","Date","now","_running","_done","_unblockTime","ready","clients","_startHeartbeat","base","heartbeat","reservoirRefreshInterval","reservoirRefreshAmount","reservoirIncreaseInterval","reservoirIncreaseAmount","setInterval","amount","incr","maximum","reservoir","_drainAll","computeCapacity","_this$storeOptions","reservoirIncreaseMaximum","Math","min","heartbeatInterval","unref","clearInterval","__publish__","message","_this","yieldLoop","Events","trigger","toString","__disconnect__","flush","_this2","t","setTimeout","computePenalty","ref","penalty","minTime","__updateSettings__","options","_this3","overwrite","__running__","_this4","__queued__","_this5","queued","__done__","_this6","__groupCheck__","time","_this7","timeout","maxConcurrent","_this$storeOptions2","conditionsCheck","weight","capacity","__incrementReservoir__","_this8","__currentReservoir__","_this9","isBlocked","check","__check__","_this10","__register__","index","expiration","_this11","wait","max","success","strategyIsBlock","strategy","__submit__","queueLength","_this12","blocked","reachedHWM","highWater","_dropAllQueued","__free__","_this13","running","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar BottleneckError, LocalDatastore, parser;\nparser = require(\"./parser\");\nBottleneckError = require(\"./BottleneckError\");\nLocalDatastore = class LocalDatastore {\n  constructor(instance, storeOptions, storeInstanceOptions) {\n    this.instance = instance;\n    this.storeOptions = storeOptions;\n    this.clientId = this.instance._randomIndex();\n    parser.load(storeInstanceOptions, storeInstanceOptions, this);\n    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n    this._running = 0;\n    this._done = 0;\n    this._unblockTime = 0;\n    this.ready = this.Promise.resolve();\n    this.clients = {};\n\n    this._startHeartbeat();\n  }\n\n  _startHeartbeat() {\n    var base;\n\n    if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {\n      return typeof (base = this.heartbeat = setInterval(() => {\n        var amount, incr, maximum, now, reservoir;\n        now = Date.now();\n\n        if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\n          this._lastReservoirRefresh = now;\n          this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\n\n          this.instance._drainAll(this.computeCapacity());\n        }\n\n        if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\n          var _this$storeOptions = this.storeOptions;\n          amount = _this$storeOptions.reservoirIncreaseAmount;\n          maximum = _this$storeOptions.reservoirIncreaseMaximum;\n          reservoir = _this$storeOptions.reservoir;\n          this._lastReservoirIncrease = now;\n          incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n\n          if (incr > 0) {\n            this.storeOptions.reservoir += incr;\n            return this.instance._drainAll(this.computeCapacity());\n          }\n        }\n      }, this.heartbeatInterval)).unref === \"function\" ? base.unref() : void 0;\n    } else {\n      return clearInterval(this.heartbeat);\n    }\n  }\n\n  __publish__(message) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.yieldLoop();\n      return _this.instance.Events.trigger(\"message\", message.toString());\n    })();\n  }\n\n  __disconnect__(flush) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.yieldLoop();\n      clearInterval(_this2.heartbeat);\n      return _this2.Promise.resolve();\n    })();\n  }\n\n  yieldLoop(t = 0) {\n    return new this.Promise(function (resolve, reject) {\n      return setTimeout(resolve, t);\n    });\n  }\n\n  computePenalty() {\n    var ref;\n    return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;\n  }\n\n  __updateSettings__(options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.yieldLoop();\n      parser.overwrite(options, options, _this3.storeOptions);\n\n      _this3._startHeartbeat();\n\n      _this3.instance._drainAll(_this3.computeCapacity());\n\n      return true;\n    })();\n  }\n\n  __running__() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.yieldLoop();\n      return _this4._running;\n    })();\n  }\n\n  __queued__() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.yieldLoop();\n      return _this5.instance.queued();\n    })();\n  }\n\n  __done__() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6.yieldLoop();\n      return _this6._done;\n    })();\n  }\n\n  __groupCheck__(time) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this7.yieldLoop();\n      return _this7._nextRequest + _this7.timeout < time;\n    })();\n  }\n\n  computeCapacity() {\n    var maxConcurrent, reservoir;\n    var _this$storeOptions2 = this.storeOptions;\n    maxConcurrent = _this$storeOptions2.maxConcurrent;\n    reservoir = _this$storeOptions2.reservoir;\n\n    if (maxConcurrent != null && reservoir != null) {\n      return Math.min(maxConcurrent - this._running, reservoir);\n    } else if (maxConcurrent != null) {\n      return maxConcurrent - this._running;\n    } else if (reservoir != null) {\n      return reservoir;\n    } else {\n      return null;\n    }\n  }\n\n  conditionsCheck(weight) {\n    var capacity;\n    capacity = this.computeCapacity();\n    return capacity == null || weight <= capacity;\n  }\n\n  __incrementReservoir__(incr) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var reservoir;\n      yield _this8.yieldLoop();\n      reservoir = _this8.storeOptions.reservoir += incr;\n\n      _this8.instance._drainAll(_this8.computeCapacity());\n\n      return reservoir;\n    })();\n  }\n\n  __currentReservoir__() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this9.yieldLoop();\n      return _this9.storeOptions.reservoir;\n    })();\n  }\n\n  isBlocked(now) {\n    return this._unblockTime >= now;\n  }\n\n  check(weight, now) {\n    return this.conditionsCheck(weight) && this._nextRequest - now <= 0;\n  }\n\n  __check__(weight) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      var now;\n      yield _this10.yieldLoop();\n      now = Date.now();\n      return _this10.check(weight, now);\n    })();\n  }\n\n  __register__(index, weight, expiration) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      var now, wait;\n      yield _this11.yieldLoop();\n      now = Date.now();\n\n      if (_this11.conditionsCheck(weight)) {\n        _this11._running += weight;\n\n        if (_this11.storeOptions.reservoir != null) {\n          _this11.storeOptions.reservoir -= weight;\n        }\n\n        wait = Math.max(_this11._nextRequest - now, 0);\n        _this11._nextRequest = now + wait + _this11.storeOptions.minTime;\n        return {\n          success: true,\n          wait,\n          reservoir: _this11.storeOptions.reservoir\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    })();\n  }\n\n  strategyIsBlock() {\n    return this.storeOptions.strategy === 3;\n  }\n\n  __submit__(queueLength, weight) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      var blocked, now, reachedHWM;\n      yield _this12.yieldLoop();\n\n      if (_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent) {\n        throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this12.storeOptions.maxConcurrent}`);\n      }\n\n      now = Date.now();\n      reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);\n      blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));\n\n      if (blocked) {\n        _this12._unblockTime = now + _this12.computePenalty();\n        _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;\n\n        _this12.instance._dropAllQueued();\n      }\n\n      return {\n        reachedHWM,\n        blocked,\n        strategy: _this12.storeOptions.strategy\n      };\n    })();\n  }\n\n  __free__(index, weight) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this13.yieldLoop();\n      _this13._running -= weight;\n      _this13._done += weight;\n\n      _this13.instance._drainAll(_this13.computeCapacity());\n\n      return {\n        running: _this13._running\n      };\n    })();\n  }\n\n};\nmodule.exports = LocalDatastore;"]},"metadata":{},"sourceType":"script"}