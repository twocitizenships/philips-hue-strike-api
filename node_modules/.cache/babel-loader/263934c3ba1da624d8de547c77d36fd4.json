{"ast":null,"code":"import { RECURRING_RANDOMIZED_TIME_REGEX } from './timeUtil';\nimport { RecurringTime } from './RecurringTime';\nimport { HueTime } from './HueTime';\nimport { HueBridgeModelError } from '../HueBridgeModelError';\nexport class RecurringRandomizedTime extends RecurringTime {\n  constructor() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    super();\n    this._random = new HueTime();\n\n    if (arguments.length > 0) {\n      this.setValue(...arguments);\n    }\n  }\n\n  static matches(value) {\n    return RECURRING_RANDOMIZED_TIME_REGEX.test(value);\n  }\n\n  setValue() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    // This is all a little convoluted due to large number of parameters it supports, could do with some work on making\n    // it clearer as to the path (although tests do provide coverage).\n    let weekdays = null,\n        date = null;\n\n    if (arguments.length > 1) {\n      weekdays = arguments[0];\n      date = arguments[1];\n    } else if (arguments.length === 1) {\n      const argOne = arguments[0];\n\n      if (argOne instanceof RecurringRandomizedTime) {\n        return this.setValue(argOne.toString());\n      } else if (argOne instanceof Date) {\n        date = argOne;\n      } else if (Number.isInteger(argOne)) {\n        weekdays = argOne;\n      }\n    }\n\n    if (date) {\n      this._time.fromDate(date);\n    }\n\n    if (weekdays) {\n      this.weekdays(weekdays);\n    }\n\n    const parsed = RECURRING_RANDOMIZED_TIME_REGEX.exec(arguments[0]);\n\n    if (parsed) {\n      const time = this._time; // @ts-ignore\n\n      time.hours = parsed.groups.hours; // @ts-ignore\n\n      time.minutes = parsed.groups.minutes; // @ts-ignore\n\n      time.seconds = parsed.groups.seconds; // @ts-ignore\n\n      this.weekdays(parsed.groups.weekdays);\n      const random = this._random; // @ts-ignore\n\n      random.hours = parsed.groups.randomhours; // @ts-ignore\n\n      random.minutes = parsed.groups.randomminutes; // @ts-ignore\n\n      random.seconds = parsed.groups.randomseconds;\n      return this;\n    }\n\n    if (!weekdays && !date) {\n      const values = Array.from(arguments).join(', ');\n      throw new HueBridgeModelError(`Cannot create an recurring time from ${values}`);\n    }\n\n    return this;\n  }\n\n  randomHours(value) {\n    this._random.hours = value;\n    return this;\n  }\n\n  randomMinutes(value) {\n    this._random.minutes = value;\n    return this;\n  }\n\n  randomSeconds(value) {\n    this._random.seconds = value;\n    return this;\n  }\n\n  toString() {\n    return `${super.toString()}A${this._random.toString()}`;\n  }\n\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/time/RecurringRandomizedTime.js"],"names":["RECURRING_RANDOMIZED_TIME_REGEX","RecurringTime","HueTime","HueBridgeModelError","RecurringRandomizedTime","constructor","args","_random","arguments","length","setValue","matches","value","test","weekdays","date","argOne","toString","Date","Number","isInteger","_time","fromDate","parsed","exec","time","hours","groups","minutes","seconds","random","randomhours","randomminutes","randomseconds","values","Array","from","join","randomHours","randomMinutes","randomSeconds"],"mappings":"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","sourcesContent":["import { RECURRING_RANDOMIZED_TIME_REGEX } from './timeUtil';\nimport { RecurringTime } from './RecurringTime';\nimport { HueTime } from './HueTime';\nimport { HueBridgeModelError } from '../HueBridgeModelError';\nexport class RecurringRandomizedTime extends RecurringTime {\n    constructor(...args) {\n        super();\n        this._random = new HueTime();\n        if (arguments.length > 0) {\n            this.setValue(...arguments);\n        }\n    }\n    static matches(value) {\n        return RECURRING_RANDOMIZED_TIME_REGEX.test(value);\n    }\n    setValue(...args) {\n        // This is all a little convoluted due to large number of parameters it supports, could do with some work on making\n        // it clearer as to the path (although tests do provide coverage).\n        let weekdays = null, date = null;\n        if (arguments.length > 1) {\n            weekdays = arguments[0];\n            date = arguments[1];\n        }\n        else if (arguments.length === 1) {\n            const argOne = arguments[0];\n            if (argOne instanceof RecurringRandomizedTime) {\n                return this.setValue(argOne.toString());\n            }\n            else if (argOne instanceof Date) {\n                date = argOne;\n            }\n            else if (Number.isInteger(argOne)) {\n                weekdays = argOne;\n            }\n        }\n        if (date) {\n            this._time.fromDate(date);\n        }\n        if (weekdays) {\n            this.weekdays(weekdays);\n        }\n        const parsed = RECURRING_RANDOMIZED_TIME_REGEX.exec(arguments[0]);\n        if (parsed) {\n            const time = this._time;\n            // @ts-ignore\n            time.hours = parsed.groups.hours;\n            // @ts-ignore\n            time.minutes = parsed.groups.minutes;\n            // @ts-ignore\n            time.seconds = parsed.groups.seconds;\n            // @ts-ignore\n            this.weekdays(parsed.groups.weekdays);\n            const random = this._random;\n            // @ts-ignore\n            random.hours = parsed.groups.randomhours;\n            // @ts-ignore\n            random.minutes = parsed.groups.randomminutes;\n            // @ts-ignore\n            random.seconds = parsed.groups.randomseconds;\n            return this;\n        }\n        if (!weekdays && !date) {\n            const values = Array.from(arguments).join(', ');\n            throw new HueBridgeModelError(`Cannot create an recurring time from ${values}`);\n        }\n        return this;\n    }\n    randomHours(value) {\n        this._random.hours = value;\n        return this;\n    }\n    randomMinutes(value) {\n        this._random.minutes = value;\n        return this;\n    }\n    randomSeconds(value) {\n        this._random.seconds = value;\n        return this;\n    }\n    toString() {\n        return `${super.toString()}A${this._random.toString()}`;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}