{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.request = exports.create = exports.HttpClientFetch = void 0;\n\nconst node_fetch_1 = __importDefault(require(\"node-fetch\"));\n\nconst url_1 = require(\"url\");\n\nconst HttpError_1 = __importDefault(require(\"./HttpError\"));\n\nclass HttpClientFetch {\n  constructor(config) {\n    this._config = config || {};\n  }\n\n  get headers() {\n    return this._config.headers || {};\n  }\n\n  get baseURL() {\n    return this._config.baseURL;\n  }\n\n  get hasBaseUrl() {\n    return !!this.baseURL;\n  }\n\n  getTimeout(timeout) {\n    var _a;\n\n    if (timeout !== undefined) {\n      return timeout;\n    }\n\n    return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.timeout) || 0;\n  }\n\n  refreshAuthorizationHeader(token) {\n    if (!this._config.headers) {\n      this._config.headers = {};\n    }\n\n    this._config.headers['Authorization'] = `Bearer ${token}`;\n  }\n\n  getAgent(url, config) {\n    const specifiedAgent = config.agent || config.httpsAgent || config.httpAgent || undefined;\n\n    if (specifiedAgent) {\n      return specifiedAgent;\n    }\n\n    return this._config.httpsAgent || this._config.httpAgent || undefined;\n  }\n\n  getUrl(url) {\n    if (!this.hasBaseUrl) {\n      return url;\n    } else if (/^http/.test(url)) {\n      return url;\n    }\n\n    let path;\n\n    if (url && url[0] === '/') {\n      path = url;\n    } else {\n      path = `/${url}`;\n    }\n\n    return `${this.baseURL}${path}`;\n  }\n\n  request(req) {\n    const isJson = req.json === true,\n          hasData = !!req.data,\n          url = this.getUrl(req.url),\n          headers = this.headers,\n          config = {\n      method: req.method,\n      headers: headers,\n      timeout: this.getTimeout(req.timeout)\n    }; // We are setting the timeout on the HTTP(s) agent, but node-fetch does not appear to be respecting this setting\n    // from the agent, so taking to explicitly extracting the timeout from the agent and setting it on the API call\n    // if a timeout is not specified as part of the request.\n\n    if (isJson) {\n      headers['Content-Type'] = 'application/json';\n      headers['Accept'] = 'application/json';\n\n      if (hasData) {\n        config.body = JSON.stringify(req.data);\n      }\n    } else {\n      if (hasData) {\n        config.body = req.data;\n      }\n    }\n\n    if (req.headers) {\n      const requestHeaders = req.headers;\n      Object.keys(requestHeaders).forEach(header => {\n        headers[header] = requestHeaders[header];\n      });\n    }\n\n    if (req.params) {\n      config.body = new url_1.URLSearchParams(req.params);\n      headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n    }\n\n    config.agent = this.getAgent(url, req);\n    return (0, node_fetch_1.default)(url, config).then(res => {\n      if (req.validateStatus) {\n        if (req.validateStatus(res.status)) {\n          return res;\n        }\n      } else if (res.ok) {\n        return res;\n      } // Process the result and then return the error object\n\n\n      return resolveBodyPromise(res).then(data => {\n        throw new HttpError_1.default(res.status, res.url, res.headers.raw(), data);\n      });\n    }).then(res => {\n      const result = {\n        status: res.status\n      };\n\n      if (res.headers) {\n        // @ts-ignore\n        result.headers = res.headers.raw();\n      }\n\n      return resolveBodyPromise(res).then(data => {\n        result.data = data;\n        return result;\n      });\n    });\n  }\n\n}\n\nexports.HttpClientFetch = HttpClientFetch;\n\nfunction resolveBodyPromise(res) {\n  // The local bridge connection with nginx in front of it does not return a content-length header, unlike the remote API\n  // so we cannot gate on this and prevent calls to res.json() from errorring on an empty string.\n  //\n  // This means we need to get it back as text and process it accordingly.\n  // let promise;\n  // const contentLength: string = res.headers.get('content-length');\n  // if (contentLength && parseInt(contentLength) > 0) {\n  //   const contentType = res.headers.get('content-type');\n  //\n  //   if (contentType.startsWith('application/json')) {\n  //     promise = res.json();\n  //   } else {\n  //     promise = res.text();\n  //   }\n  // } else {\n  //   promise = Promise.resolve();\n  // }\n  // return promise;\n  return res.text().then(data => {\n    const contentType = res.headers.get('content-type');\n\n    if (contentType && contentType.startsWith('application/json')) {\n      try {\n        return JSON.parse(data);\n      } catch (err) {\n        return data;\n      }\n    }\n\n    return data;\n  });\n}\n\nfunction create(config) {\n  return new HttpClientFetch(config);\n}\n\nexports.create = create;\n\nfunction request(req) {\n  return new HttpClientFetch().request(req);\n}\n\nexports.request = request;","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/node-hue-api/dist/cjs/api/http/HttpClientFetch.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","request","create","HttpClientFetch","node_fetch_1","require","url_1","HttpError_1","constructor","config","_config","headers","baseURL","hasBaseUrl","getTimeout","timeout","_a","undefined","refreshAuthorizationHeader","token","getAgent","url","specifiedAgent","agent","httpsAgent","httpAgent","getUrl","test","path","req","isJson","json","hasData","data","method","body","JSON","stringify","requestHeaders","keys","forEach","header","params","URLSearchParams","default","then","res","validateStatus","status","ok","resolveBodyPromise","raw","result","text","contentType","get","startsWith","parse","err"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.request = exports.create = exports.HttpClientFetch = void 0;\nconst node_fetch_1 = __importDefault(require(\"node-fetch\"));\nconst url_1 = require(\"url\");\nconst HttpError_1 = __importDefault(require(\"./HttpError\"));\nclass HttpClientFetch {\n    constructor(config) {\n        this._config = config || {};\n    }\n    get headers() {\n        return this._config.headers || {};\n    }\n    get baseURL() {\n        return this._config.baseURL;\n    }\n    get hasBaseUrl() {\n        return !!this.baseURL;\n    }\n    getTimeout(timeout) {\n        var _a;\n        if (timeout !== undefined) {\n            return timeout;\n        }\n        return ((_a = this._config) === null || _a === void 0 ? void 0 : _a.timeout) || 0;\n    }\n    refreshAuthorizationHeader(token) {\n        if (!this._config.headers) {\n            this._config.headers = {};\n        }\n        this._config.headers['Authorization'] = `Bearer ${token}`;\n    }\n    getAgent(url, config) {\n        const specifiedAgent = config.agent || config.httpsAgent || config.httpAgent || undefined;\n        if (specifiedAgent) {\n            return specifiedAgent;\n        }\n        return this._config.httpsAgent || this._config.httpAgent || undefined;\n    }\n    getUrl(url) {\n        if (!this.hasBaseUrl) {\n            return url;\n        }\n        else if (/^http/.test(url)) {\n            return url;\n        }\n        let path;\n        if (url && url[0] === '/') {\n            path = url;\n        }\n        else {\n            path = `/${url}`;\n        }\n        return `${this.baseURL}${path}`;\n    }\n    request(req) {\n        const isJson = req.json === true, hasData = !!req.data, url = this.getUrl(req.url), headers = this.headers, config = {\n            method: req.method,\n            headers: headers,\n            timeout: this.getTimeout(req.timeout),\n        };\n        // We are setting the timeout on the HTTP(s) agent, but node-fetch does not appear to be respecting this setting\n        // from the agent, so taking to explicitly extracting the timeout from the agent and setting it on the API call\n        // if a timeout is not specified as part of the request.\n        if (isJson) {\n            headers['Content-Type'] = 'application/json';\n            headers['Accept'] = 'application/json';\n            if (hasData) {\n                config.body = JSON.stringify(req.data);\n            }\n        }\n        else {\n            if (hasData) {\n                config.body = req.data;\n            }\n        }\n        if (req.headers) {\n            const requestHeaders = req.headers;\n            Object.keys(requestHeaders).forEach(header => {\n                headers[header] = requestHeaders[header];\n            });\n        }\n        if (req.params) {\n            config.body = new url_1.URLSearchParams(req.params);\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        }\n        config.agent = this.getAgent(url, req);\n        return (0, node_fetch_1.default)(url, config)\n            .then((res) => {\n            if (req.validateStatus) {\n                if (req.validateStatus(res.status)) {\n                    return res;\n                }\n            }\n            else if (res.ok) {\n                return res;\n            }\n            // Process the result and then return the error object\n            return resolveBodyPromise(res)\n                .then(data => {\n                throw new HttpError_1.default(res.status, res.url, res.headers.raw(), data);\n            });\n        })\n            .then((res) => {\n            const result = {\n                status: res.status,\n            };\n            if (res.headers) {\n                // @ts-ignore\n                result.headers = res.headers.raw();\n            }\n            return resolveBodyPromise(res)\n                .then(data => {\n                result.data = data;\n                return result;\n            });\n        });\n    }\n}\nexports.HttpClientFetch = HttpClientFetch;\nfunction resolveBodyPromise(res) {\n    // The local bridge connection with nginx in front of it does not return a content-length header, unlike the remote API\n    // so we cannot gate on this and prevent calls to res.json() from errorring on an empty string.\n    //\n    // This means we need to get it back as text and process it accordingly.\n    // let promise;\n    // const contentLength: string = res.headers.get('content-length');\n    // if (contentLength && parseInt(contentLength) > 0) {\n    //   const contentType = res.headers.get('content-type');\n    //\n    //   if (contentType.startsWith('application/json')) {\n    //     promise = res.json();\n    //   } else {\n    //     promise = res.text();\n    //   }\n    // } else {\n    //   promise = Promise.resolve();\n    // }\n    // return promise;\n    return res.text()\n        .then((data) => {\n        const contentType = res.headers.get('content-type');\n        if (contentType && contentType.startsWith('application/json')) {\n            try {\n                return JSON.parse(data);\n            }\n            catch (err) {\n                return data;\n            }\n        }\n        return data;\n    });\n}\nfunction create(config) {\n    return new HttpClientFetch(config);\n}\nexports.create = create;\nfunction request(req) {\n    return new HttpClientFetch().request(req);\n}\nexports.request = request;\n"]},"metadata":{},"sourceType":"script"}