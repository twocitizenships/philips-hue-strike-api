{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseXmlDescription = exports.getBridgeDescription = exports.getBridgeConfig = void 0;\n\nconst HttpClientFetch_1 = require(\"../http/HttpClientFetch\");\n\nconst ApiError_1 = require(\"../../ApiError\");\n\nconst FRIENDLY_NAME = /<friendlyName>(.*)<\\/friendlyName/sm,\n      MODEL_NAME = /<modelName>(.*)<\\/modelName/sm,\n      MODEL_NUMBER = /<modelNumber>(.*)<\\/modelNumber/sm,\n      MODEL_DESCRIPTION = /<modelDescription>(.*)<\\/modelDescription>/sm,\n      MANUFACTURER = /<manufacturer>(.*)<\\/manufacturer>/sm,\n      SERIAL_NUMBER = /<serialNumber>(.*)<\\/serialNumber/sm,\n      IP_ADDRESS = /<URLBase>http[s]?:\\/\\/(.*):.*<\\/URLBase/sm,\n      SPEC_VERSION = /<specVersion>.*<major>(.*)<\\/.*<minor>(.*)<\\/.*<\\/specVersion/sm,\n      ICON_LIST = /<iconList>(.*)<\\/iconList>/sm,\n      ICON_MIME_TYPE = /<mimetype>(.*)<\\/mimetype>/sm,\n      ICON_HEIGHT = /<height>(.*)<\\/height>/sm,\n      ICON_WIDTH = /<width>(.*)<\\/width>/sm,\n      ICON_DEPTH = /<depth>(.*)<\\/depth>/sm,\n      ICON_URL = /<url>(.*)<\\/url>/sm;\nconst DATA_TIMEOUT = 6000;\n\nfunction getBridgeConfig(bridge, timeout) {\n  const ipAddress = bridge.internalipaddress;\n  return (0, HttpClientFetch_1.request)({\n    method: 'get',\n    url: `http://${ipAddress}/api/config`,\n    timeout: timeout || DATA_TIMEOUT,\n    json: true\n  }).catch(err => {\n    throw new ApiError_1.ApiError(`Problem connecting to bridge '${ipAddress}'; ${err.message}`);\n  }).then(res => {\n    if (res.status !== 200) {\n      throw new ApiError_1.ApiError(`Unexpected status when getting unauthenticated configuration date from bridge at ${ipAddress}, status ${res.status}`);\n    }\n\n    const result = {};\n    result.name = res.data.name;\n    result.ipaddress = ipAddress;\n    result.modelid = res.data.modelid;\n    result.swversion = res.data.swversion;\n    return result;\n  });\n}\n\nexports.getBridgeConfig = getBridgeConfig;\n\nfunction getBridgeDescription(bridge, timeout) {\n  const ipAddress = bridge.internalipaddress;\n  return (0, HttpClientFetch_1.request)({\n    method: 'GET',\n    url: `http://${ipAddress}/description.xml`,\n    timeout: timeout || DATA_TIMEOUT,\n    headers: {\n      accept: 'text/xml'\n    }\n  }) // return axios.request({\n  //     method: 'GET',\n  //     url: `http://${ipAddress}/description.xml`,\n  //     timeout: timeout | DATA_TIMEOUT,\n  //     headers: {\n  //       accept: 'text/xml'\n  //     }\n  //   })\n  .catch(err => {\n    throw new ApiError_1.ApiError(`Failed to resolve the XML Description for the bridge at ${ipAddress}; ${err.message}`);\n  }).then(res => {\n    if (res.status !== 200) {\n      throw new ApiError_1.ApiError(`Unexpected status when getting XML Description from bridge at ${ipAddress}`);\n    }\n\n    return parseXmlDescription(res.data);\n  });\n}\n\nexports.getBridgeDescription = getBridgeDescription;\n\nfunction parseXmlDescription(data) {\n  // This is an XML payload, but we will use Regex to parse out the details we want to save pulling in yet another\n  // dependency for something so trivial.\n  const result = {};\n  Object.assign(result, extractValue('name', data, FRIENDLY_NAME));\n  Object.assign(result, extractValue('manufacturer', data, MANUFACTURER));\n  Object.assign(result, extractValue('ipaddress', data, IP_ADDRESS));\n  const model = getModel(data);\n\n  if (model) {\n    result.model = model;\n  }\n\n  const specVersion = getSpecVersion(data);\n\n  if (specVersion) {\n    result.version = specVersion;\n  }\n\n  const icons = getIcons(data);\n\n  if (icons) {\n    result.icons = icons;\n  }\n\n  return result;\n}\n\nexports.parseXmlDescription = parseXmlDescription;\n\nfunction extractValue(name, data, regex) {\n  const matched = regex.exec(data);\n\n  if (!matched) {\n    return undefined;\n  }\n\n  const result = {};\n  result[name] = matched[1];\n  return result;\n}\n\nfunction getModel(data) {\n  const result = {};\n  Object.assign(result, extractValue('number', data, MODEL_NUMBER));\n  Object.assign(result, extractValue('description', data, MODEL_DESCRIPTION));\n  Object.assign(result, extractValue('name', data, MODEL_NAME));\n  Object.assign(result, extractValue('serial', data, SERIAL_NUMBER));\n  return result;\n}\n\nfunction getIcons(data) {\n  const iconListMatch = ICON_LIST.exec(data);\n\n  if (iconListMatch) {\n    const iconList = iconListMatch[1],\n          unparsedIcons = iconList.split('</icon>'),\n          results = [];\n    unparsedIcons.forEach(unparsedIcon => {\n      const icon = getIcon(unparsedIcon);\n\n      if (icon) {\n        results.push(icon);\n      }\n    });\n    return results;\n  }\n\n  return undefined;\n}\n\nfunction getIcon(data) {\n  const result = {};\n  Object.assign(result, extractValue('mimetype', data, ICON_MIME_TYPE));\n  Object.assign(result, extractValue('height', data, ICON_HEIGHT));\n  Object.assign(result, extractValue('width', data, ICON_WIDTH));\n  Object.assign(result, extractValue('depth', data, ICON_DEPTH));\n  Object.assign(result, extractValue('url', data, ICON_URL));\n\n  if (Object.keys(result).length > 0) {\n    return result;\n  }\n\n  return undefined;\n}\n\nfunction getSpecVersion(data) {\n  const matched = SPEC_VERSION.exec(data);\n\n  if (matched) {\n    return {\n      major: matched[1],\n      minor: matched[2]\n    };\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/node-hue-api/dist/cjs/api/discovery/bridge-validation.js"],"names":["Object","defineProperty","exports","value","parseXmlDescription","getBridgeDescription","getBridgeConfig","HttpClientFetch_1","require","ApiError_1","FRIENDLY_NAME","MODEL_NAME","MODEL_NUMBER","MODEL_DESCRIPTION","MANUFACTURER","SERIAL_NUMBER","IP_ADDRESS","SPEC_VERSION","ICON_LIST","ICON_MIME_TYPE","ICON_HEIGHT","ICON_WIDTH","ICON_DEPTH","ICON_URL","DATA_TIMEOUT","bridge","timeout","ipAddress","internalipaddress","request","method","url","json","catch","err","ApiError","message","then","res","status","result","name","data","ipaddress","modelid","swversion","headers","accept","assign","extractValue","model","getModel","specVersion","getSpecVersion","version","icons","getIcons","regex","matched","exec","undefined","iconListMatch","iconList","unparsedIcons","split","results","forEach","unparsedIcon","icon","getIcon","push","keys","length","major","minor"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseXmlDescription = exports.getBridgeDescription = exports.getBridgeConfig = void 0;\nconst HttpClientFetch_1 = require(\"../http/HttpClientFetch\");\nconst ApiError_1 = require(\"../../ApiError\");\nconst FRIENDLY_NAME = /<friendlyName>(.*)<\\/friendlyName/sm, MODEL_NAME = /<modelName>(.*)<\\/modelName/sm, MODEL_NUMBER = /<modelNumber>(.*)<\\/modelNumber/sm, MODEL_DESCRIPTION = /<modelDescription>(.*)<\\/modelDescription>/sm, MANUFACTURER = /<manufacturer>(.*)<\\/manufacturer>/sm, SERIAL_NUMBER = /<serialNumber>(.*)<\\/serialNumber/sm, IP_ADDRESS = /<URLBase>http[s]?:\\/\\/(.*):.*<\\/URLBase/sm, SPEC_VERSION = /<specVersion>.*<major>(.*)<\\/.*<minor>(.*)<\\/.*<\\/specVersion/sm, ICON_LIST = /<iconList>(.*)<\\/iconList>/sm, ICON_MIME_TYPE = /<mimetype>(.*)<\\/mimetype>/sm, ICON_HEIGHT = /<height>(.*)<\\/height>/sm, ICON_WIDTH = /<width>(.*)<\\/width>/sm, ICON_DEPTH = /<depth>(.*)<\\/depth>/sm, ICON_URL = /<url>(.*)<\\/url>/sm;\nconst DATA_TIMEOUT = 6000;\nfunction getBridgeConfig(bridge, timeout) {\n    const ipAddress = bridge.internalipaddress;\n    return (0, HttpClientFetch_1.request)({\n        method: 'get',\n        url: `http://${ipAddress}/api/config`,\n        timeout: timeout || DATA_TIMEOUT,\n        json: true,\n    })\n        .catch(err => {\n        throw new ApiError_1.ApiError(`Problem connecting to bridge '${ipAddress}'; ${err.message}`);\n    })\n        .then(res => {\n        if (res.status !== 200) {\n            throw new ApiError_1.ApiError(`Unexpected status when getting unauthenticated configuration date from bridge at ${ipAddress}, status ${res.status}`);\n        }\n        const result = {};\n        result.name = res.data.name;\n        result.ipaddress = ipAddress;\n        result.modelid = res.data.modelid;\n        result.swversion = res.data.swversion;\n        return result;\n    });\n}\nexports.getBridgeConfig = getBridgeConfig;\nfunction getBridgeDescription(bridge, timeout) {\n    const ipAddress = bridge.internalipaddress;\n    return (0, HttpClientFetch_1.request)({\n        method: 'GET',\n        url: `http://${ipAddress}/description.xml`,\n        timeout: timeout || DATA_TIMEOUT,\n        headers: {\n            accept: 'text/xml'\n        }\n    })\n        // return axios.request({\n        //     method: 'GET',\n        //     url: `http://${ipAddress}/description.xml`,\n        //     timeout: timeout | DATA_TIMEOUT,\n        //     headers: {\n        //       accept: 'text/xml'\n        //     }\n        //   })\n        .catch(err => {\n        throw new ApiError_1.ApiError(`Failed to resolve the XML Description for the bridge at ${ipAddress}; ${err.message}`);\n    })\n        .then(res => {\n        if (res.status !== 200) {\n            throw new ApiError_1.ApiError(`Unexpected status when getting XML Description from bridge at ${ipAddress}`);\n        }\n        return parseXmlDescription(res.data);\n    });\n}\nexports.getBridgeDescription = getBridgeDescription;\nfunction parseXmlDescription(data) {\n    // This is an XML payload, but we will use Regex to parse out the details we want to save pulling in yet another\n    // dependency for something so trivial.\n    const result = {};\n    Object.assign(result, extractValue('name', data, FRIENDLY_NAME));\n    Object.assign(result, extractValue('manufacturer', data, MANUFACTURER));\n    Object.assign(result, extractValue('ipaddress', data, IP_ADDRESS));\n    const model = getModel(data);\n    if (model) {\n        result.model = model;\n    }\n    const specVersion = getSpecVersion(data);\n    if (specVersion) {\n        result.version = specVersion;\n    }\n    const icons = getIcons(data);\n    if (icons) {\n        result.icons = icons;\n    }\n    return result;\n}\nexports.parseXmlDescription = parseXmlDescription;\nfunction extractValue(name, data, regex) {\n    const matched = regex.exec(data);\n    if (!matched) {\n        return undefined;\n    }\n    const result = {};\n    result[name] = matched[1];\n    return result;\n}\nfunction getModel(data) {\n    const result = {};\n    Object.assign(result, extractValue('number', data, MODEL_NUMBER));\n    Object.assign(result, extractValue('description', data, MODEL_DESCRIPTION));\n    Object.assign(result, extractValue('name', data, MODEL_NAME));\n    Object.assign(result, extractValue('serial', data, SERIAL_NUMBER));\n    return result;\n}\nfunction getIcons(data) {\n    const iconListMatch = ICON_LIST.exec(data);\n    if (iconListMatch) {\n        const iconList = iconListMatch[1], unparsedIcons = iconList.split('</icon>'), results = [];\n        unparsedIcons.forEach(unparsedIcon => {\n            const icon = getIcon(unparsedIcon);\n            if (icon) {\n                results.push(icon);\n            }\n        });\n        return results;\n    }\n    return undefined;\n}\nfunction getIcon(data) {\n    const result = {};\n    Object.assign(result, extractValue('mimetype', data, ICON_MIME_TYPE));\n    Object.assign(result, extractValue('height', data, ICON_HEIGHT));\n    Object.assign(result, extractValue('width', data, ICON_WIDTH));\n    Object.assign(result, extractValue('depth', data, ICON_DEPTH));\n    Object.assign(result, extractValue('url', data, ICON_URL));\n    if (Object.keys(result).length > 0) {\n        return result;\n    }\n    return undefined;\n}\nfunction getSpecVersion(data) {\n    const matched = SPEC_VERSION.exec(data);\n    if (matched) {\n        return {\n            major: matched[1],\n            minor: matched[2]\n        };\n    }\n    return undefined;\n}\n"]},"metadata":{},"sourceType":"script"}