{"ast":null,"code":"\"use strict\";\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar Bottleneck,\n    DEFAULT_PRIORITY,\n    Events,\n    Job,\n    LocalDatastore,\n    NUM_PRIORITIES,\n    Queues,\n    RedisDatastore,\n    States,\n    Sync,\n    parser,\n    splice = [].splice;\nNUM_PRIORITIES = 10;\nDEFAULT_PRIORITY = 5;\nparser = require(\"./parser\");\nQueues = require(\"./Queues\");\nJob = require(\"./Job\");\nLocalDatastore = require(\"./LocalDatastore\");\nRedisDatastore = require(\"./RedisDatastore\");\nEvents = require(\"./Events\");\nStates = require(\"./States\");\nSync = require(\"./Sync\");\n\nBottleneck = function () {\n  class Bottleneck {\n    constructor() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var storeInstanceOptions, storeOptions;\n      this._addToQueue = this._addToQueue.bind(this);\n\n      for (var _len = arguments.length, invalid = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        invalid[_key - 1] = arguments[_key];\n      }\n\n      this._validateOptions(options, invalid);\n\n      parser.load(options, this.instanceDefaults, this);\n      this._queues = new Queues(NUM_PRIORITIES);\n      this._scheduled = {};\n      this._states = new States([\"RECEIVED\", \"QUEUED\", \"RUNNING\", \"EXECUTING\"].concat(this.trackDoneStatus ? [\"DONE\"] : []));\n      this._limiter = null;\n      this.Events = new Events(this);\n      this._submitLock = new Sync(\"submit\", this.Promise);\n      this._registerLock = new Sync(\"register\", this.Promise);\n      storeOptions = parser.load(options, this.storeDefaults, {});\n\n      this._store = function () {\n        if (this.datastore === \"redis\" || this.datastore === \"ioredis\" || this.connection != null) {\n          storeInstanceOptions = parser.load(options, this.redisStoreDefaults, {});\n          return new RedisDatastore(this, storeOptions, storeInstanceOptions);\n        } else if (this.datastore === \"local\") {\n          storeInstanceOptions = parser.load(options, this.localStoreDefaults, {});\n          return new LocalDatastore(this, storeOptions, storeInstanceOptions);\n        } else {\n          throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);\n        }\n      }.call(this);\n\n      this._queues.on(\"leftzero\", () => {\n        var ref;\n        return (ref = this._store.heartbeat) != null ? typeof ref.ref === \"function\" ? ref.ref() : void 0 : void 0;\n      });\n\n      this._queues.on(\"zero\", () => {\n        var ref;\n        return (ref = this._store.heartbeat) != null ? typeof ref.unref === \"function\" ? ref.unref() : void 0 : void 0;\n      });\n    }\n\n    _validateOptions(options, invalid) {\n      if (!(options != null && typeof options === \"object\" && invalid.length === 0)) {\n        throw new Bottleneck.prototype.BottleneckError(\"Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.\");\n      }\n    }\n\n    ready() {\n      return this._store.ready;\n    }\n\n    clients() {\n      return this._store.clients;\n    }\n\n    channel() {\n      return `b_${this.id}`;\n    }\n\n    channel_client() {\n      return `b_${this.id}_${this._store.clientId}`;\n    }\n\n    publish(message) {\n      return this._store.__publish__(message);\n    }\n\n    disconnect() {\n      let flush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this._store.__disconnect__(flush);\n    }\n\n    chain(_limiter) {\n      this._limiter = _limiter;\n      return this;\n    }\n\n    queued(priority) {\n      return this._queues.queued(priority);\n    }\n\n    clusterQueued() {\n      return this._store.__queued__();\n    }\n\n    empty() {\n      return this.queued() === 0 && this._submitLock.isEmpty();\n    }\n\n    running() {\n      return this._store.__running__();\n    }\n\n    done() {\n      return this._store.__done__();\n    }\n\n    jobStatus(id) {\n      return this._states.jobStatus(id);\n    }\n\n    jobs(status) {\n      return this._states.statusJobs(status);\n    }\n\n    counts() {\n      return this._states.statusCounts();\n    }\n\n    _randomIndex() {\n      return Math.random().toString(36).slice(2);\n    }\n\n    check() {\n      let weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      return this._store.__check__(weight);\n    }\n\n    _clearGlobalState(index) {\n      if (this._scheduled[index] != null) {\n        clearTimeout(this._scheduled[index].expiration);\n        delete this._scheduled[index];\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    _free(index, job, options, eventInfo) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        var e, running;\n\n        try {\n          var _ref = yield _this._store.__free__(index, options.weight);\n\n          running = _ref.running;\n\n          _this.Events.trigger(\"debug\", `Freed ${options.id}`, eventInfo);\n\n          if (running === 0 && _this.empty()) {\n            return _this.Events.trigger(\"idle\");\n          }\n        } catch (error1) {\n          e = error1;\n          return _this.Events.trigger(\"error\", e);\n        }\n      })();\n    }\n\n    _run(index, job, wait) {\n      var clearGlobalState, free, run;\n      job.doRun();\n      clearGlobalState = this._clearGlobalState.bind(this, index);\n      run = this._run.bind(this, index, job);\n      free = this._free.bind(this, index, job);\n      return this._scheduled[index] = {\n        timeout: setTimeout(() => {\n          return job.doExecute(this._limiter, clearGlobalState, run, free);\n        }, wait),\n        expiration: job.options.expiration != null ? setTimeout(function () {\n          return job.doExpire(clearGlobalState, run, free);\n        }, wait + job.options.expiration) : void 0,\n        job: job\n      };\n    }\n\n    _drainOne(capacity) {\n      return this._registerLock.schedule(() => {\n        var args, index, next, options, queue;\n\n        if (this.queued() === 0) {\n          return this.Promise.resolve(null);\n        }\n\n        queue = this._queues.getFirst();\n\n        var _next2 = next = queue.first();\n\n        options = _next2.options;\n        args = _next2.args;\n\n        if (capacity != null && options.weight > capacity) {\n          return this.Promise.resolve(null);\n        }\n\n        this.Events.trigger(\"debug\", `Draining ${options.id}`, {\n          args,\n          options\n        });\n        index = this._randomIndex();\n        return this._store.__register__(index, options.weight, options.expiration).then(_ref7 => {\n          let {\n            success,\n            wait,\n            reservoir\n          } = _ref7;\n          var empty;\n          this.Events.trigger(\"debug\", `Drained ${options.id}`, {\n            success,\n            args,\n            options\n          });\n\n          if (success) {\n            queue.shift();\n            empty = this.empty();\n\n            if (empty) {\n              this.Events.trigger(\"empty\");\n            }\n\n            if (reservoir === 0) {\n              this.Events.trigger(\"depleted\", empty);\n            }\n\n            this._run(index, next, wait);\n\n            return this.Promise.resolve(options.weight);\n          } else {\n            return this.Promise.resolve(null);\n          }\n        });\n      });\n    }\n\n    _drainAll(capacity) {\n      let total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this._drainOne(capacity).then(drained => {\n        var newCapacity;\n\n        if (drained != null) {\n          newCapacity = capacity != null ? capacity - drained : capacity;\n          return this._drainAll(newCapacity, total + drained);\n        } else {\n          return this.Promise.resolve(total);\n        }\n      }).catch(e => {\n        return this.Events.trigger(\"error\", e);\n      });\n    }\n\n    _dropAllQueued(message) {\n      return this._queues.shiftAll(function (job) {\n        return job.doDrop({\n          message\n        });\n      });\n    }\n\n    stop() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var done, waitForExecuting;\n      options = parser.load(options, this.stopDefaults);\n\n      waitForExecuting = at => {\n        var finished;\n\n        finished = () => {\n          var counts;\n          counts = this._states.counts;\n          return counts[0] + counts[1] + counts[2] + counts[3] === at;\n        };\n\n        return new this.Promise((resolve, reject) => {\n          if (finished()) {\n            return resolve();\n          } else {\n            return this.on(\"done\", () => {\n              if (finished()) {\n                this.removeAllListeners(\"done\");\n                return resolve();\n              }\n            });\n          }\n        });\n      };\n\n      done = options.dropWaitingJobs ? (this._run = function (index, next) {\n        return next.doDrop({\n          message: options.dropErrorMessage\n        });\n      }, this._drainOne = () => {\n        return this.Promise.resolve(null);\n      }, this._registerLock.schedule(() => {\n        return this._submitLock.schedule(() => {\n          var k, ref, v;\n          ref = this._scheduled;\n\n          for (k in ref) {\n            v = ref[k];\n\n            if (this.jobStatus(v.job.options.id) === \"RUNNING\") {\n              clearTimeout(v.timeout);\n              clearTimeout(v.expiration);\n              v.job.doDrop({\n                message: options.dropErrorMessage\n              });\n            }\n          }\n\n          this._dropAllQueued(options.dropErrorMessage);\n\n          return waitForExecuting(0);\n        });\n      })) : this.schedule({\n        priority: NUM_PRIORITIES - 1,\n        weight: 0\n      }, () => {\n        return waitForExecuting(1);\n      });\n\n      this._receive = function (job) {\n        return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));\n      };\n\n      this.stop = () => {\n        return this.Promise.reject(new Bottleneck.prototype.BottleneckError(\"stop() has already been called\"));\n      };\n\n      return done;\n    }\n\n    _addToQueue(job) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        var args, blocked, error, options, reachedHWM, shifted, strategy;\n        args = job.args;\n        options = job.options;\n\n        try {\n          var _ref2 = yield _this2._store.__submit__(_this2.queued(), options.weight);\n\n          reachedHWM = _ref2.reachedHWM;\n          blocked = _ref2.blocked;\n          strategy = _ref2.strategy;\n        } catch (error1) {\n          error = error1;\n\n          _this2.Events.trigger(\"debug\", `Could not queue ${options.id}`, {\n            args,\n            options,\n            error\n          });\n\n          job.doDrop({\n            error\n          });\n          return false;\n        }\n\n        if (blocked) {\n          job.doDrop();\n          return true;\n        } else if (reachedHWM) {\n          shifted = strategy === Bottleneck.prototype.strategy.LEAK ? _this2._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? _this2._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;\n\n          if (shifted != null) {\n            shifted.doDrop();\n          }\n\n          if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {\n            if (shifted == null) {\n              job.doDrop();\n            }\n\n            return reachedHWM;\n          }\n        }\n\n        job.doQueue(reachedHWM, blocked);\n\n        _this2._queues.push(job);\n\n        yield _this2._drainAll();\n        return reachedHWM;\n      })();\n    }\n\n    _receive(job) {\n      if (this._states.jobStatus(job.options.id) != null) {\n        job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));\n\n        return false;\n      } else {\n        job.doReceive();\n        return this._submitLock.schedule(this._addToQueue, job);\n      }\n    }\n\n    submit() {\n      var _this4 = this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var cb, fn, job, options, ref, ref1, task;\n\n      if (typeof args[0] === \"function\") {\n        var _ref3, _ref4, _splice$call, _splice$call2;\n\n        ref = args, (_ref3 = ref, _ref4 = _toArray(_ref3), fn = _ref4[0], args = _ref4.slice(1), _ref3), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0], _splice$call);\n        options = parser.load({}, this.jobDefaults);\n      } else {\n        var _ref5, _ref6, _splice$call3, _splice$call4;\n\n        ref1 = args, (_ref5 = ref1, _ref6 = _toArray(_ref5), options = _ref6[0], fn = _ref6[1], args = _ref6.slice(2), _ref5), (_splice$call3 = splice.call(args, -1), _splice$call4 = _slicedToArray(_splice$call3, 1), cb = _splice$call4[0], _splice$call3);\n        options = parser.load(options, this.jobDefaults);\n      }\n\n      task = function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return new _this4.Promise(function (resolve, reject) {\n          return fn(...args, function () {\n            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              args[_key4] = arguments[_key4];\n            }\n\n            return (args[0] != null ? reject : resolve)(args);\n          });\n        });\n      };\n\n      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n      job.promise.then(function (args) {\n        return typeof cb === \"function\" ? cb(...args) : void 0;\n      }).catch(function (args) {\n        if (Array.isArray(args)) {\n          return typeof cb === \"function\" ? cb(...args) : void 0;\n        } else {\n          return typeof cb === \"function\" ? cb(args) : void 0;\n        }\n      });\n      return this._receive(job);\n    }\n\n    schedule() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      var job, options, task;\n\n      if (typeof args[0] === \"function\") {\n        var _args = args;\n\n        var _args2 = _toArray(_args);\n\n        task = _args2[0];\n        args = _args2.slice(1);\n        options = {};\n      } else {\n        var _args3 = args;\n\n        var _args4 = _toArray(_args3);\n\n        options = _args4[0];\n        task = _args4[1];\n        args = _args4.slice(2);\n      }\n\n      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n\n      this._receive(job);\n\n      return job.promise;\n    }\n\n    wrap(fn) {\n      var schedule, wrapped;\n      schedule = this.schedule.bind(this);\n\n      wrapped = function wrapped() {\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n\n        return schedule(fn.bind(this), ...args);\n      };\n\n      wrapped.withOptions = function (options) {\n        for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n          args[_key7 - 1] = arguments[_key7];\n        }\n\n        return schedule(options, fn, ...args);\n      };\n\n      return wrapped;\n    }\n\n    updateSettings() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this3._store.__updateSettings__(parser.overwrite(options, _this3.storeDefaults));\n        parser.overwrite(options, _this3.instanceDefaults, _this3);\n        return _this3;\n      })();\n    }\n\n    currentReservoir() {\n      return this._store.__currentReservoir__();\n    }\n\n    incrementReservoir() {\n      let incr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this._store.__incrementReservoir__(incr);\n    }\n\n  }\n\n  ;\n  Bottleneck.default = Bottleneck;\n  Bottleneck.Events = Events;\n  Bottleneck.version = Bottleneck.prototype.version = require(\"./version.json\").version;\n  Bottleneck.strategy = Bottleneck.prototype.strategy = {\n    LEAK: 1,\n    OVERFLOW: 2,\n    OVERFLOW_PRIORITY: 4,\n    BLOCK: 3\n  };\n  Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = require(\"./BottleneckError\");\n  Bottleneck.Group = Bottleneck.prototype.Group = require(\"./Group\");\n  Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require(\"./RedisConnection\");\n  Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require(\"./IORedisConnection\");\n  Bottleneck.Batcher = Bottleneck.prototype.Batcher = require(\"./Batcher\");\n  Bottleneck.prototype.jobDefaults = {\n    priority: DEFAULT_PRIORITY,\n    weight: 1,\n    expiration: null,\n    id: \"<no-id>\"\n  };\n  Bottleneck.prototype.storeDefaults = {\n    maxConcurrent: null,\n    minTime: 0,\n    highWater: null,\n    strategy: Bottleneck.prototype.strategy.LEAK,\n    penalty: null,\n    reservoir: null,\n    reservoirRefreshInterval: null,\n    reservoirRefreshAmount: null,\n    reservoirIncreaseInterval: null,\n    reservoirIncreaseAmount: null,\n    reservoirIncreaseMaximum: null\n  };\n  Bottleneck.prototype.localStoreDefaults = {\n    Promise: Promise,\n    timeout: null,\n    heartbeatInterval: 250\n  };\n  Bottleneck.prototype.redisStoreDefaults = {\n    Promise: Promise,\n    timeout: null,\n    heartbeatInterval: 5000,\n    clientTimeout: 10000,\n    Redis: null,\n    clientOptions: {},\n    clusterNodes: null,\n    clearDatastore: false,\n    connection: null\n  };\n  Bottleneck.prototype.instanceDefaults = {\n    datastore: \"local\",\n    connection: null,\n    id: \"<no-id>\",\n    rejectOnDrop: true,\n    trackDoneStatus: false,\n    Promise: Promise\n  };\n  Bottleneck.prototype.stopDefaults = {\n    enqueueErrorMessage: \"This limiter has been stopped and cannot accept new jobs.\",\n    dropWaitingJobs: true,\n    dropErrorMessage: \"This limiter has been stopped.\"\n  };\n  return Bottleneck;\n}.call(void 0);\n\nmodule.exports = Bottleneck;","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/bottleneck/lib/Bottleneck.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","_toArray","_iterableToArray","TypeError","iter","Object","prototype","toString","call","Array","from","isArray","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","error","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","Bottleneck","DEFAULT_PRIORITY","Events","Job","LocalDatastore","NUM_PRIORITIES","Queues","RedisDatastore","States","Sync","parser","splice","require","constructor","options","storeInstanceOptions","storeOptions","_addToQueue","bind","invalid","_validateOptions","load","instanceDefaults","_queues","_scheduled","_states","concat","trackDoneStatus","_limiter","_submitLock","_registerLock","storeDefaults","_store","datastore","connection","redisStoreDefaults","localStoreDefaults","BottleneckError","on","ref","heartbeat","unref","ready","clients","channel","id","channel_client","clientId","publish","message","__publish__","disconnect","flush","__disconnect__","chain","queued","priority","clusterQueued","__queued__","empty","isEmpty","running","__running__","__done__","jobStatus","jobs","status","statusJobs","counts","statusCounts","_randomIndex","Math","random","slice","check","weight","__check__","_clearGlobalState","index","clearTimeout","expiration","_free","job","eventInfo","_this","e","_ref","__free__","trigger","error1","_run","wait","clearGlobalState","free","run","doRun","timeout","setTimeout","doExecute","doExpire","_drainOne","capacity","schedule","queue","getFirst","_next2","first","__register__","success","reservoir","shift","_drainAll","total","drained","newCapacity","catch","_dropAllQueued","shiftAll","doDrop","stop","waitForExecuting","stopDefaults","at","finished","removeAllListeners","dropWaitingJobs","dropErrorMessage","k","v","_receive","_reject","enqueueErrorMessage","_this2","blocked","reachedHWM","shifted","strategy","_ref2","__submit__","LEAK","shiftLastFrom","OVERFLOW_PRIORITY","OVERFLOW","doQueue","doReceive","submit","cb","ref1","task","_ref3","_ref4","_splice$call","_splice$call2","jobDefaults","_ref5","_ref6","_splice$call3","_splice$call4","rejectOnDrop","promise","_args","_args2","_args3","_args4","wrap","wrapped","withOptions","updateSettings","_this3","__updateSettings__","overwrite","currentReservoir","__currentReservoir__","incrementReservoir","incr","__incrementReservoir__","default","version","BLOCK","Group","RedisConnection","IORedisConnection","Batcher","maxConcurrent","minTime","highWater","penalty","reservoirRefreshInterval","reservoirRefreshAmount","reservoirIncreaseInterval","reservoirIncreaseAmount","reservoirIncreaseMaximum","heartbeatInterval","clientTimeout","Redis","clientOptions","clusterNodes","clearDatastore","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar Bottleneck,\n    DEFAULT_PRIORITY,\n    Events,\n    Job,\n    LocalDatastore,\n    NUM_PRIORITIES,\n    Queues,\n    RedisDatastore,\n    States,\n    Sync,\n    parser,\n    splice = [].splice;\nNUM_PRIORITIES = 10;\nDEFAULT_PRIORITY = 5;\nparser = require(\"./parser\");\nQueues = require(\"./Queues\");\nJob = require(\"./Job\");\nLocalDatastore = require(\"./LocalDatastore\");\nRedisDatastore = require(\"./RedisDatastore\");\nEvents = require(\"./Events\");\nStates = require(\"./States\");\nSync = require(\"./Sync\");\n\nBottleneck = function () {\n  class Bottleneck {\n    constructor(options = {}, ...invalid) {\n      var storeInstanceOptions, storeOptions;\n      this._addToQueue = this._addToQueue.bind(this);\n\n      this._validateOptions(options, invalid);\n\n      parser.load(options, this.instanceDefaults, this);\n      this._queues = new Queues(NUM_PRIORITIES);\n      this._scheduled = {};\n      this._states = new States([\"RECEIVED\", \"QUEUED\", \"RUNNING\", \"EXECUTING\"].concat(this.trackDoneStatus ? [\"DONE\"] : []));\n      this._limiter = null;\n      this.Events = new Events(this);\n      this._submitLock = new Sync(\"submit\", this.Promise);\n      this._registerLock = new Sync(\"register\", this.Promise);\n      storeOptions = parser.load(options, this.storeDefaults, {});\n\n      this._store = function () {\n        if (this.datastore === \"redis\" || this.datastore === \"ioredis\" || this.connection != null) {\n          storeInstanceOptions = parser.load(options, this.redisStoreDefaults, {});\n          return new RedisDatastore(this, storeOptions, storeInstanceOptions);\n        } else if (this.datastore === \"local\") {\n          storeInstanceOptions = parser.load(options, this.localStoreDefaults, {});\n          return new LocalDatastore(this, storeOptions, storeInstanceOptions);\n        } else {\n          throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);\n        }\n      }.call(this);\n\n      this._queues.on(\"leftzero\", () => {\n        var ref;\n        return (ref = this._store.heartbeat) != null ? typeof ref.ref === \"function\" ? ref.ref() : void 0 : void 0;\n      });\n\n      this._queues.on(\"zero\", () => {\n        var ref;\n        return (ref = this._store.heartbeat) != null ? typeof ref.unref === \"function\" ? ref.unref() : void 0 : void 0;\n      });\n    }\n\n    _validateOptions(options, invalid) {\n      if (!(options != null && typeof options === \"object\" && invalid.length === 0)) {\n        throw new Bottleneck.prototype.BottleneckError(\"Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.\");\n      }\n    }\n\n    ready() {\n      return this._store.ready;\n    }\n\n    clients() {\n      return this._store.clients;\n    }\n\n    channel() {\n      return `b_${this.id}`;\n    }\n\n    channel_client() {\n      return `b_${this.id}_${this._store.clientId}`;\n    }\n\n    publish(message) {\n      return this._store.__publish__(message);\n    }\n\n    disconnect(flush = true) {\n      return this._store.__disconnect__(flush);\n    }\n\n    chain(_limiter) {\n      this._limiter = _limiter;\n      return this;\n    }\n\n    queued(priority) {\n      return this._queues.queued(priority);\n    }\n\n    clusterQueued() {\n      return this._store.__queued__();\n    }\n\n    empty() {\n      return this.queued() === 0 && this._submitLock.isEmpty();\n    }\n\n    running() {\n      return this._store.__running__();\n    }\n\n    done() {\n      return this._store.__done__();\n    }\n\n    jobStatus(id) {\n      return this._states.jobStatus(id);\n    }\n\n    jobs(status) {\n      return this._states.statusJobs(status);\n    }\n\n    counts() {\n      return this._states.statusCounts();\n    }\n\n    _randomIndex() {\n      return Math.random().toString(36).slice(2);\n    }\n\n    check(weight = 1) {\n      return this._store.__check__(weight);\n    }\n\n    _clearGlobalState(index) {\n      if (this._scheduled[index] != null) {\n        clearTimeout(this._scheduled[index].expiration);\n        delete this._scheduled[index];\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    _free(index, job, options, eventInfo) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        var e, running;\n\n        try {\n          var _ref = yield _this._store.__free__(index, options.weight);\n\n          running = _ref.running;\n\n          _this.Events.trigger(\"debug\", `Freed ${options.id}`, eventInfo);\n\n          if (running === 0 && _this.empty()) {\n            return _this.Events.trigger(\"idle\");\n          }\n        } catch (error1) {\n          e = error1;\n          return _this.Events.trigger(\"error\", e);\n        }\n      })();\n    }\n\n    _run(index, job, wait) {\n      var clearGlobalState, free, run;\n      job.doRun();\n      clearGlobalState = this._clearGlobalState.bind(this, index);\n      run = this._run.bind(this, index, job);\n      free = this._free.bind(this, index, job);\n      return this._scheduled[index] = {\n        timeout: setTimeout(() => {\n          return job.doExecute(this._limiter, clearGlobalState, run, free);\n        }, wait),\n        expiration: job.options.expiration != null ? setTimeout(function () {\n          return job.doExpire(clearGlobalState, run, free);\n        }, wait + job.options.expiration) : void 0,\n        job: job\n      };\n    }\n\n    _drainOne(capacity) {\n      return this._registerLock.schedule(() => {\n        var args, index, next, options, queue;\n\n        if (this.queued() === 0) {\n          return this.Promise.resolve(null);\n        }\n\n        queue = this._queues.getFirst();\n\n        var _next2 = next = queue.first();\n\n        options = _next2.options;\n        args = _next2.args;\n\n        if (capacity != null && options.weight > capacity) {\n          return this.Promise.resolve(null);\n        }\n\n        this.Events.trigger(\"debug\", `Draining ${options.id}`, {\n          args,\n          options\n        });\n        index = this._randomIndex();\n        return this._store.__register__(index, options.weight, options.expiration).then(({\n          success,\n          wait,\n          reservoir\n        }) => {\n          var empty;\n          this.Events.trigger(\"debug\", `Drained ${options.id}`, {\n            success,\n            args,\n            options\n          });\n\n          if (success) {\n            queue.shift();\n            empty = this.empty();\n\n            if (empty) {\n              this.Events.trigger(\"empty\");\n            }\n\n            if (reservoir === 0) {\n              this.Events.trigger(\"depleted\", empty);\n            }\n\n            this._run(index, next, wait);\n\n            return this.Promise.resolve(options.weight);\n          } else {\n            return this.Promise.resolve(null);\n          }\n        });\n      });\n    }\n\n    _drainAll(capacity, total = 0) {\n      return this._drainOne(capacity).then(drained => {\n        var newCapacity;\n\n        if (drained != null) {\n          newCapacity = capacity != null ? capacity - drained : capacity;\n          return this._drainAll(newCapacity, total + drained);\n        } else {\n          return this.Promise.resolve(total);\n        }\n      }).catch(e => {\n        return this.Events.trigger(\"error\", e);\n      });\n    }\n\n    _dropAllQueued(message) {\n      return this._queues.shiftAll(function (job) {\n        return job.doDrop({\n          message\n        });\n      });\n    }\n\n    stop(options = {}) {\n      var done, waitForExecuting;\n      options = parser.load(options, this.stopDefaults);\n\n      waitForExecuting = at => {\n        var finished;\n\n        finished = () => {\n          var counts;\n          counts = this._states.counts;\n          return counts[0] + counts[1] + counts[2] + counts[3] === at;\n        };\n\n        return new this.Promise((resolve, reject) => {\n          if (finished()) {\n            return resolve();\n          } else {\n            return this.on(\"done\", () => {\n              if (finished()) {\n                this.removeAllListeners(\"done\");\n                return resolve();\n              }\n            });\n          }\n        });\n      };\n\n      done = options.dropWaitingJobs ? (this._run = function (index, next) {\n        return next.doDrop({\n          message: options.dropErrorMessage\n        });\n      }, this._drainOne = () => {\n        return this.Promise.resolve(null);\n      }, this._registerLock.schedule(() => {\n        return this._submitLock.schedule(() => {\n          var k, ref, v;\n          ref = this._scheduled;\n\n          for (k in ref) {\n            v = ref[k];\n\n            if (this.jobStatus(v.job.options.id) === \"RUNNING\") {\n              clearTimeout(v.timeout);\n              clearTimeout(v.expiration);\n              v.job.doDrop({\n                message: options.dropErrorMessage\n              });\n            }\n          }\n\n          this._dropAllQueued(options.dropErrorMessage);\n\n          return waitForExecuting(0);\n        });\n      })) : this.schedule({\n        priority: NUM_PRIORITIES - 1,\n        weight: 0\n      }, () => {\n        return waitForExecuting(1);\n      });\n\n      this._receive = function (job) {\n        return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));\n      };\n\n      this.stop = () => {\n        return this.Promise.reject(new Bottleneck.prototype.BottleneckError(\"stop() has already been called\"));\n      };\n\n      return done;\n    }\n\n    _addToQueue(job) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        var args, blocked, error, options, reachedHWM, shifted, strategy;\n        args = job.args;\n        options = job.options;\n\n        try {\n          var _ref2 = yield _this2._store.__submit__(_this2.queued(), options.weight);\n\n          reachedHWM = _ref2.reachedHWM;\n          blocked = _ref2.blocked;\n          strategy = _ref2.strategy;\n        } catch (error1) {\n          error = error1;\n\n          _this2.Events.trigger(\"debug\", `Could not queue ${options.id}`, {\n            args,\n            options,\n            error\n          });\n\n          job.doDrop({\n            error\n          });\n          return false;\n        }\n\n        if (blocked) {\n          job.doDrop();\n          return true;\n        } else if (reachedHWM) {\n          shifted = strategy === Bottleneck.prototype.strategy.LEAK ? _this2._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? _this2._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;\n\n          if (shifted != null) {\n            shifted.doDrop();\n          }\n\n          if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {\n            if (shifted == null) {\n              job.doDrop();\n            }\n\n            return reachedHWM;\n          }\n        }\n\n        job.doQueue(reachedHWM, blocked);\n\n        _this2._queues.push(job);\n\n        yield _this2._drainAll();\n        return reachedHWM;\n      })();\n    }\n\n    _receive(job) {\n      if (this._states.jobStatus(job.options.id) != null) {\n        job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));\n\n        return false;\n      } else {\n        job.doReceive();\n        return this._submitLock.schedule(this._addToQueue, job);\n      }\n    }\n\n    submit(...args) {\n      var cb, fn, job, options, ref, ref1, task;\n\n      if (typeof args[0] === \"function\") {\n        var _ref3, _ref4, _splice$call, _splice$call2;\n\n        ref = args, (_ref3 = ref, _ref4 = _toArray(_ref3), fn = _ref4[0], args = _ref4.slice(1), _ref3), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0], _splice$call);\n        options = parser.load({}, this.jobDefaults);\n      } else {\n        var _ref5, _ref6, _splice$call3, _splice$call4;\n\n        ref1 = args, (_ref5 = ref1, _ref6 = _toArray(_ref5), options = _ref6[0], fn = _ref6[1], args = _ref6.slice(2), _ref5), (_splice$call3 = splice.call(args, -1), _splice$call4 = _slicedToArray(_splice$call3, 1), cb = _splice$call4[0], _splice$call3);\n        options = parser.load(options, this.jobDefaults);\n      }\n\n      task = (...args) => {\n        return new this.Promise(function (resolve, reject) {\n          return fn(...args, function (...args) {\n            return (args[0] != null ? reject : resolve)(args);\n          });\n        });\n      };\n\n      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n      job.promise.then(function (args) {\n        return typeof cb === \"function\" ? cb(...args) : void 0;\n      }).catch(function (args) {\n        if (Array.isArray(args)) {\n          return typeof cb === \"function\" ? cb(...args) : void 0;\n        } else {\n          return typeof cb === \"function\" ? cb(args) : void 0;\n        }\n      });\n      return this._receive(job);\n    }\n\n    schedule(...args) {\n      var job, options, task;\n\n      if (typeof args[0] === \"function\") {\n        var _args = args;\n\n        var _args2 = _toArray(_args);\n\n        task = _args2[0];\n        args = _args2.slice(1);\n        options = {};\n      } else {\n        var _args3 = args;\n\n        var _args4 = _toArray(_args3);\n\n        options = _args4[0];\n        task = _args4[1];\n        args = _args4.slice(2);\n      }\n\n      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n\n      this._receive(job);\n\n      return job.promise;\n    }\n\n    wrap(fn) {\n      var schedule, wrapped;\n      schedule = this.schedule.bind(this);\n\n      wrapped = function wrapped(...args) {\n        return schedule(fn.bind(this), ...args);\n      };\n\n      wrapped.withOptions = function (options, ...args) {\n        return schedule(options, fn, ...args);\n      };\n\n      return wrapped;\n    }\n\n    updateSettings(options = {}) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this3._store.__updateSettings__(parser.overwrite(options, _this3.storeDefaults));\n        parser.overwrite(options, _this3.instanceDefaults, _this3);\n        return _this3;\n      })();\n    }\n\n    currentReservoir() {\n      return this._store.__currentReservoir__();\n    }\n\n    incrementReservoir(incr = 0) {\n      return this._store.__incrementReservoir__(incr);\n    }\n\n  }\n\n  ;\n  Bottleneck.default = Bottleneck;\n  Bottleneck.Events = Events;\n  Bottleneck.version = Bottleneck.prototype.version = require(\"./version.json\").version;\n  Bottleneck.strategy = Bottleneck.prototype.strategy = {\n    LEAK: 1,\n    OVERFLOW: 2,\n    OVERFLOW_PRIORITY: 4,\n    BLOCK: 3\n  };\n  Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = require(\"./BottleneckError\");\n  Bottleneck.Group = Bottleneck.prototype.Group = require(\"./Group\");\n  Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require(\"./RedisConnection\");\n  Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require(\"./IORedisConnection\");\n  Bottleneck.Batcher = Bottleneck.prototype.Batcher = require(\"./Batcher\");\n  Bottleneck.prototype.jobDefaults = {\n    priority: DEFAULT_PRIORITY,\n    weight: 1,\n    expiration: null,\n    id: \"<no-id>\"\n  };\n  Bottleneck.prototype.storeDefaults = {\n    maxConcurrent: null,\n    minTime: 0,\n    highWater: null,\n    strategy: Bottleneck.prototype.strategy.LEAK,\n    penalty: null,\n    reservoir: null,\n    reservoirRefreshInterval: null,\n    reservoirRefreshAmount: null,\n    reservoirIncreaseInterval: null,\n    reservoirIncreaseAmount: null,\n    reservoirIncreaseMaximum: null\n  };\n  Bottleneck.prototype.localStoreDefaults = {\n    Promise: Promise,\n    timeout: null,\n    heartbeatInterval: 250\n  };\n  Bottleneck.prototype.redisStoreDefaults = {\n    Promise: Promise,\n    timeout: null,\n    heartbeatInterval: 5000,\n    clientTimeout: 10000,\n    Redis: null,\n    clientOptions: {},\n    clusterNodes: null,\n    clearDatastore: false,\n    connection: null\n  };\n  Bottleneck.prototype.instanceDefaults = {\n    datastore: \"local\",\n    connection: null,\n    id: \"<no-id>\",\n    rejectOnDrop: true,\n    trackDoneStatus: false,\n    Promise: Promise\n  };\n  Bottleneck.prototype.stopDefaults = {\n    enqueueErrorMessage: \"This limiter has been stopped and cannot accept new jobs.\",\n    dropWaitingJobs: true,\n    dropErrorMessage: \"This limiter has been stopped.\"\n  };\n  return Bottleneck;\n}.call(void 0);\n\nmodule.exports = Bottleneck;"]},"metadata":{},"sourceType":"script"}