{"ast":null,"code":"import { Group } from '../../groups/Group';\nimport { RuleCondition } from './RuleCondition';\nimport { getOperator } from './operators';\nimport { HueBridgeModelError } from '../../../HueBridgeModelError';\nexport class GroupCondition {\n  constructor(id) {\n    this.groupStateAttribute = null;\n    this._operator = null;\n\n    if (id instanceof Group) {\n      this.id = id.id;\n    } else {\n      this.id = id;\n    }\n  }\n\n  when() {\n    return new SelectAttribute(this);\n  }\n\n  getRuleCondition() {\n    validateState(this);\n    const data = {\n      address: `/groups/${this.id}/state/${this.groupStateAttribute}`,\n      // @ts-ignore\n      operator: this._operator\n    };\n\n    if (this.value !== undefined && this.value !== null) {\n      data['value'] = this.value;\n    }\n\n    return new RuleCondition(data);\n  }\n\n  get operator() {\n    return this._operator;\n  }\n\n  setOperator(value) {\n    const operator = getOperator(value);\n\n    if (operator) {\n      this._operator = operator;\n    } else {\n      throw new HueBridgeModelError(`Failed to resolve an operator for: '${JSON.stringify(value)}'`);\n    }\n  }\n\n  _setRequiredValue(value) {\n    if (value === null) {\n      throw new HueBridgeModelError('A value is required when using this operator');\n    }\n\n    this.value = value;\n  }\n\n}\n;\n\nfunction validateState(condition) {\n  let message = null;\n\n  if (condition.id === null || condition.id === undefined) {\n    message = 'a group id is required';\n  } else if (!condition.groupStateAttribute) {\n    message = 'a state of the group is required';\n  } else if (!condition.operator) {\n    message = 'an operator for the group state value is required';\n  } //TODO some operators require a value, others do not, might need to validate that here too, should have a function on the operator to check is a value is required\n\n\n  if (message) {\n    throw new HueBridgeModelError(`Invalid Condition, ${message}`);\n  }\n}\n\nexport class SelectAttribute {\n  constructor(condition) {\n    this._condition = condition;\n    this._selectOperator = new SelectOperator(condition);\n  }\n\n  allOn() {\n    this._condition.groupStateAttribute = 'all_on';\n    return this._selectOperator;\n  }\n\n  anyOn() {\n    this._condition.groupStateAttribute = 'any_on';\n    return this._selectOperator;\n  }\n\n}\nexport class SelectOperator {\n  constructor(condition) {\n    this._condition = condition;\n  }\n\n  equals(val) {\n    this._condition.setOperator('eq');\n\n    this._condition._setRequiredValue(val);\n\n    return this._condition;\n  }\n\n  changed() {\n    this._condition.setOperator('dx'); // Clear any value that might have been set in the past\n\n\n    this._condition.value = undefined;\n    return this._condition;\n  }\n\n  changedDelayed(val) {\n    this._condition.setOperator('ddx');\n\n    this._condition._setRequiredValue(val); //TODO not sure this is required for ddx\n\n\n    return this._condition;\n  }\n\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/model/rules/conditions/GroupCondition.js"],"names":["Group","RuleCondition","getOperator","HueBridgeModelError","GroupCondition","constructor","id","groupStateAttribute","_operator","when","SelectAttribute","getRuleCondition","validateState","data","address","operator","value","undefined","setOperator","JSON","stringify","_setRequiredValue","condition","message","_condition","_selectOperator","SelectOperator","allOn","anyOn","equals","val","changed","changedDelayed"],"mappings":"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","sourcesContent":["import { Group } from '../../groups/Group';\nimport { RuleCondition } from './RuleCondition';\nimport { getOperator } from './operators';\nimport { HueBridgeModelError } from '../../../HueBridgeModelError';\nexport class GroupCondition {\n    constructor(id) {\n        this.groupStateAttribute = null;\n        this._operator = null;\n        if (id instanceof Group) {\n            this.id = id.id;\n        }\n        else {\n            this.id = id;\n        }\n    }\n    when() {\n        return new SelectAttribute(this);\n    }\n    getRuleCondition() {\n        validateState(this);\n        const data = {\n            address: `/groups/${this.id}/state/${this.groupStateAttribute}`,\n            // @ts-ignore\n            operator: this._operator,\n        };\n        if (this.value !== undefined && this.value !== null) {\n            data['value'] = this.value;\n        }\n        return new RuleCondition(data);\n    }\n    get operator() {\n        return this._operator;\n    }\n    setOperator(value) {\n        const operator = getOperator(value);\n        if (operator) {\n            this._operator = operator;\n        }\n        else {\n            throw new HueBridgeModelError(`Failed to resolve an operator for: '${JSON.stringify(value)}'`);\n        }\n    }\n    _setRequiredValue(value) {\n        if (value === null) {\n            throw new HueBridgeModelError('A value is required when using this operator');\n        }\n        this.value = value;\n    }\n}\n;\nfunction validateState(condition) {\n    let message = null;\n    if (condition.id === null || condition.id === undefined) {\n        message = 'a group id is required';\n    }\n    else if (!condition.groupStateAttribute) {\n        message = 'a state of the group is required';\n    }\n    else if (!condition.operator) {\n        message = 'an operator for the group state value is required';\n    }\n    //TODO some operators require a value, others do not, might need to validate that here too, should have a function on the operator to check is a value is required\n    if (message) {\n        throw new HueBridgeModelError(`Invalid Condition, ${message}`);\n    }\n}\nexport class SelectAttribute {\n    constructor(condition) {\n        this._condition = condition;\n        this._selectOperator = new SelectOperator(condition);\n    }\n    allOn() {\n        this._condition.groupStateAttribute = 'all_on';\n        return this._selectOperator;\n    }\n    anyOn() {\n        this._condition.groupStateAttribute = 'any_on';\n        return this._selectOperator;\n    }\n}\nexport class SelectOperator {\n    constructor(condition) {\n        this._condition = condition;\n    }\n    equals(val) {\n        this._condition.setOperator('eq');\n        this._condition._setRequiredValue(val);\n        return this._condition;\n    }\n    changed() {\n        this._condition.setOperator('dx');\n        // Clear any value that might have been set in the past\n        this._condition.value = undefined;\n        return this._condition;\n    }\n    changedDelayed(val) {\n        this._condition.setOperator('ddx');\n        this._condition._setRequiredValue(val); //TODO not sure this is required for ddx\n        return this._condition;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}