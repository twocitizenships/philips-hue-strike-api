{"ast":null,"code":"import { RECURRING_TIME_REGEX, WEEKDAY_ATTRIBUTE, WEEKDAYS } from './timeUtil';\nimport { BridgeTime } from './BridgeTime';\nimport { HueTime } from './HueTime';\nimport { HueBridgeModelError } from '../HueBridgeModelError';\nexport class RecurringTime extends BridgeTime {\n  constructor() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    super();\n    this._time = new HueTime();\n    this._weekdays = WEEKDAYS.ALL;\n\n    if (arguments.length > 0) {\n      this.setValue(...arguments);\n    }\n  }\n\n  static matches(value) {\n    return RECURRING_TIME_REGEX.test(value);\n  }\n\n  setValue() {\n    for (var _len2 = arguments.length, argsValue = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      argsValue[_key2] = arguments[_key2];\n    }\n\n    // This is all a little convoluted due to large number of parameters it supports, could do with some work on making\n    // it clearer as to the path (although tests do provide coverage).\n    let weekdays = null,\n        date = null;\n    const args = Array.from(arguments).filter(arg => arg !== undefined && arg !== null);\n\n    if (args.length > 1) {\n      weekdays = args[0];\n      date = args[1];\n    } else if (args.length === 1) {\n      const argOne = args[0];\n\n      if (argOne instanceof RecurringTime) {\n        // @ts-ignore\n        return this.setValue(argOne.toString());\n      } else if (argOne instanceof Date) {\n        date = argOne;\n      } else if (Number.isInteger(argOne)) {\n        weekdays = argOne;\n      }\n    }\n\n    if (date) {\n      this._time.fromDate(date);\n    }\n\n    if (weekdays) {\n      this.weekdays(weekdays);\n    }\n\n    const parsed = RECURRING_TIME_REGEX.exec(arguments[0]);\n\n    if (parsed) {\n      const time = this._time; // @ts-ignore\n\n      time.hours = parsed.groups.hours; // @ts-ignore\n\n      time.minutes = parsed.groups.minutes; // @ts-ignore\n\n      time.seconds = parsed.groups.seconds; // @ts-ignore\n\n      this.weekdays(parsed.groups.weekdays);\n      return this;\n    }\n\n    if (!weekdays && !date) {\n      const values = Array.from(arguments).join(', ');\n      throw new HueBridgeModelError(`Cannot create an recurring time from ${values}`);\n    }\n\n    return this;\n  }\n\n  get weekdaysString() {\n    return `${this._weekdays}`.padStart(3, '0');\n  }\n\n  weekdays(value) {\n    // @ts-ignore\n    this._weekdays = WEEKDAY_ATTRIBUTE.getValue(value);\n    return this;\n  }\n\n  hours(value) {\n    this._time.hours = value;\n    return this;\n  }\n\n  minutes(value) {\n    this._time.minutes = value;\n    return this;\n  }\n\n  seconds(value) {\n    this._time.seconds = value;\n    return this;\n  }\n\n  toString() {\n    return `W${this.weekdaysString}/T${this._time.toString()}`;\n  }\n\n}\n;","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/time/RecurringTime.js"],"names":["RECURRING_TIME_REGEX","WEEKDAY_ATTRIBUTE","WEEKDAYS","BridgeTime","HueTime","HueBridgeModelError","RecurringTime","constructor","args","_time","_weekdays","ALL","arguments","length","setValue","matches","value","test","argsValue","weekdays","date","Array","from","filter","arg","undefined","argOne","toString","Date","Number","isInteger","fromDate","parsed","exec","time","hours","groups","minutes","seconds","values","join","weekdaysString","padStart","getValue"],"mappings":"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","sourcesContent":["import { RECURRING_TIME_REGEX, WEEKDAY_ATTRIBUTE, WEEKDAYS } from './timeUtil';\nimport { BridgeTime } from './BridgeTime';\nimport { HueTime } from './HueTime';\nimport { HueBridgeModelError } from '../HueBridgeModelError';\nexport class RecurringTime extends BridgeTime {\n    constructor(...args) {\n        super();\n        this._time = new HueTime();\n        this._weekdays = WEEKDAYS.ALL;\n        if (arguments.length > 0) {\n            this.setValue(...arguments);\n        }\n    }\n    static matches(value) {\n        return RECURRING_TIME_REGEX.test(value);\n    }\n    setValue(...argsValue) {\n        // This is all a little convoluted due to large number of parameters it supports, could do with some work on making\n        // it clearer as to the path (although tests do provide coverage).\n        let weekdays = null, date = null;\n        const args = Array.from(arguments).filter(arg => arg !== undefined && arg !== null);\n        if (args.length > 1) {\n            weekdays = args[0];\n            date = args[1];\n        }\n        else if (args.length === 1) {\n            const argOne = args[0];\n            if (argOne instanceof RecurringTime) {\n                // @ts-ignore\n                return this.setValue(argOne.toString());\n            }\n            else if (argOne instanceof Date) {\n                date = argOne;\n            }\n            else if (Number.isInteger(argOne)) {\n                weekdays = argOne;\n            }\n        }\n        if (date) {\n            this._time.fromDate(date);\n        }\n        if (weekdays) {\n            this.weekdays(weekdays);\n        }\n        const parsed = RECURRING_TIME_REGEX.exec(arguments[0]);\n        if (parsed) {\n            const time = this._time;\n            // @ts-ignore\n            time.hours = parsed.groups.hours;\n            // @ts-ignore\n            time.minutes = parsed.groups.minutes;\n            // @ts-ignore\n            time.seconds = parsed.groups.seconds;\n            // @ts-ignore\n            this.weekdays(parsed.groups.weekdays);\n            return this;\n        }\n        if (!weekdays && !date) {\n            const values = Array.from(arguments).join(', ');\n            throw new HueBridgeModelError(`Cannot create an recurring time from ${values}`);\n        }\n        return this;\n    }\n    get weekdaysString() {\n        return `${this._weekdays}`.padStart(3, '0');\n    }\n    weekdays(value) {\n        // @ts-ignore\n        this._weekdays = WEEKDAY_ATTRIBUTE.getValue(value);\n        return this;\n    }\n    hours(value) {\n        this._time.hours = value;\n        return this;\n    }\n    minutes(value) {\n        this._time.minutes = value;\n        return this;\n    }\n    seconds(value) {\n        this._time.seconds = value;\n        return this;\n    }\n    toString() {\n        return `W${this.weekdaysString}/T${this._time.toString()}`;\n    }\n}\n;\n"]},"metadata":{},"sourceType":"module"}