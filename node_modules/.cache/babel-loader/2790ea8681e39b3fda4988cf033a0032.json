{"ast":null,"code":"import { isObject } from './is.js';\nexport const validateAndMerge = function () {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  for (const source of sources) {\n    if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n      throw new TypeError('The `options` argument must be an object');\n    }\n  }\n\n  return deepMerge({}, ...sources);\n};\nexport const mergeHeaders = function () {\n  let source1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let source2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = new globalThis.Headers(source1);\n  const isHeadersInstance = source2 instanceof globalThis.Headers;\n  const source = new globalThis.Headers(source2);\n\n  for (const [key, value] of source.entries()) {\n    if (isHeadersInstance && value === 'undefined' || value === undefined) {\n      result.delete(key);\n    } else {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}; // TODO: Make this strongly-typed (no `any`).\n\nexport const deepMerge = function () {\n  let returnValue = {};\n  let headers = {};\n\n  for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    sources[_key2] = arguments[_key2];\n  }\n\n  for (const source of sources) {\n    if (Array.isArray(source)) {\n      if (!Array.isArray(returnValue)) {\n        returnValue = [];\n      }\n\n      returnValue = [...returnValue, ...source];\n    } else if (isObject(source)) {\n      for (let [key, value] of Object.entries(source)) {\n        if (isObject(value) && key in returnValue) {\n          value = deepMerge(returnValue[key], value);\n        }\n\n        returnValue = { ...returnValue,\n          [key]: value\n        };\n      }\n\n      if (isObject(source.headers)) {\n        headers = mergeHeaders(headers, source.headers);\n        returnValue.headers = headers;\n      }\n    }\n  }\n\n  return returnValue;\n};","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/strike-tipping-widget/node_modules/ky/source/utils/merge.ts"],"names":[],"mappings":"AACA,SAAQ,QAAR,QAAuB,SAAvB;AAEA,OAAO,MAAM,gBAAgB,GAAG,YAAsE;AAAA,oCAAlE,OAAkE;AAAlE,IAAA,OAAkE;AAAA;;AACrG,OAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AAC7B,QAAI,CAAC,CAAC,QAAQ,CAAC,MAAD,CAAT,IAAqB,KAAK,CAAC,OAAN,CAAc,MAAd,CAAtB,KAAgD,OAAO,MAAP,KAAkB,WAAtE,EAAmF;AAClF,YAAM,IAAI,SAAJ,CAAc,0CAAd,CAAN;AACA;AACD;;AAED,SAAO,SAAS,CAAC,EAAD,EAAK,GAAG,OAAR,CAAhB;AACA,CARM;AAUP,OAAO,MAAM,YAAY,GAAG,YAA6D;AAAA,MAA5D,OAA4D,uEAAnC,EAAmC;AAAA,MAA/B,OAA+B,uEAAN,EAAM;AACxF,QAAM,MAAM,GAAG,IAAI,UAAU,CAAC,OAAf,CAAuB,OAAvB,CAAf;AACA,QAAM,iBAAiB,GAAG,OAAO,YAAY,UAAU,CAAC,OAAxD;AACA,QAAM,MAAM,GAAG,IAAI,UAAU,CAAC,OAAf,CAAuB,OAAvB,CAAf;;AAEA,OAAK,MAAM,CAAC,GAAD,EAAM,KAAN,CAAX,IAA2B,MAAM,CAAC,OAAP,EAA3B,EAA6C;AAC5C,QAAK,iBAAiB,IAAI,KAAK,KAAK,WAAhC,IAAgD,KAAK,KAAK,SAA9D,EAAyE;AACxE,MAAA,MAAM,CAAC,MAAP,CAAc,GAAd;AACA,KAFD,MAEO;AACN,MAAA,MAAM,CAAC,GAAP,CAAW,GAAX,EAAgB,KAAhB;AACA;AACD;;AAED,SAAO,MAAP;AACA,CAdM,C,CAgBP;;AACA,OAAO,MAAM,SAAS,GAAG,YAAoD;AAC5E,MAAI,WAAW,GAAQ,EAAvB;AACA,MAAI,OAAO,GAAG,EAAd;;AAF4E,qCAA7C,OAA6C;AAA7C,IAAA,OAA6C;AAAA;;AAI5E,OAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AAC7B,QAAI,KAAK,CAAC,OAAN,CAAc,MAAd,CAAJ,EAA2B;AAC1B,UAAI,CAAC,KAAK,CAAC,OAAN,CAAc,WAAd,CAAL,EAAiC;AAChC,QAAA,WAAW,GAAG,EAAd;AACA;;AAED,MAAA,WAAW,GAAG,CAAC,GAAG,WAAJ,EAAiB,GAAG,MAApB,CAAd;AACA,KAND,MAMO,IAAI,QAAQ,CAAC,MAAD,CAAZ,EAAsB;AAC5B,WAAK,IAAI,CAAC,GAAD,EAAM,KAAN,CAAT,IAAyB,MAAM,CAAC,OAAP,CAAe,MAAf,CAAzB,EAAiD;AAChD,YAAI,QAAQ,CAAC,KAAD,CAAR,IAAmB,GAAG,IAAI,WAA9B,EAA2C;AAC1C,UAAA,KAAK,GAAG,SAAS,CAAC,WAAW,CAAC,GAAD,CAAZ,EAAmB,KAAnB,CAAjB;AACA;;AAED,QAAA,WAAW,GAAG,EAAC,GAAG,WAAJ;AAAiB,WAAC,GAAD,GAAO;AAAxB,SAAd;AACA;;AAED,UAAI,QAAQ,CAAE,MAAc,CAAC,OAAjB,CAAZ,EAAuC;AACtC,QAAA,OAAO,GAAG,YAAY,CAAC,OAAD,EAAW,MAAc,CAAC,OAA1B,CAAtB;AACA,QAAA,WAAW,CAAC,OAAZ,GAAsB,OAAtB;AACA;AACD;AACD;;AAED,SAAO,WAAP;AACA,CA5BM","sourcesContent":["import type {KyHeadersInit, Options} from '../types/options.js';\nimport {isObject} from './is.js';\n\nexport const validateAndMerge = (...sources: Array<Partial<Options> | undefined>): Partial<Options> => {\n\tfor (const source of sources) {\n\t\tif ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n\t\t\tthrow new TypeError('The `options` argument must be an object');\n\t\t}\n\t}\n\n\treturn deepMerge({}, ...sources);\n};\n\nexport const mergeHeaders = (source1: KyHeadersInit = {}, source2: KyHeadersInit = {}) => {\n\tconst result = new globalThis.Headers(source1 as HeadersInit);\n\tconst isHeadersInstance = source2 instanceof globalThis.Headers;\n\tconst source = new globalThis.Headers(source2 as HeadersInit);\n\n\tfor (const [key, value] of source.entries()) {\n\t\tif ((isHeadersInstance && value === 'undefined') || value === undefined) {\n\t\t\tresult.delete(key);\n\t\t} else {\n\t\t\tresult.set(key, value);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n// TODO: Make this strongly-typed (no `any`).\nexport const deepMerge = <T>(...sources: Array<Partial<T> | undefined>): T => {\n\tlet returnValue: any = {};\n\tlet headers = {};\n\n\tfor (const source of sources) {\n\t\tif (Array.isArray(source)) {\n\t\t\tif (!Array.isArray(returnValue)) {\n\t\t\t\treturnValue = [];\n\t\t\t}\n\n\t\t\treturnValue = [...returnValue, ...source];\n\t\t} else if (isObject(source)) {\n\t\t\tfor (let [key, value] of Object.entries(source)) {\n\t\t\t\tif (isObject(value) && key in returnValue) {\n\t\t\t\t\tvalue = deepMerge(returnValue[key], value);\n\t\t\t\t}\n\n\t\t\t\treturnValue = {...returnValue, [key]: value};\n\t\t\t}\n\n\t\t\tif (isObject((source as any).headers)) {\n\t\t\t\theaders = mergeHeaders(headers, (source as any).headers);\n\t\t\t\treturnValue.headers = headers;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn returnValue;\n};\n"]},"metadata":{},"sourceType":"module"}