{"ast":null,"code":"import { BaseType } from './BaseType';\nimport { isValueDefined } from './BaseType';\nexport class RangedNumberType extends BaseType {\n  constructor(config) {\n    super({ ...{\n        type: 'RangedNumber'\n      },\n      ...config\n    });\n\n    if (isValueDefined(config.min)) {\n      // @ts-ignore\n      this.min = config.min;\n    } else {\n      this.min = config.typeMin;\n    }\n\n    if (isValueDefined(config.max)) {\n      // @ts-ignore\n      this.max = config.max;\n    } else {\n      this.max = config.typeMax;\n    }\n  }\n\n  getValue(value) {\n    const numberValue = super.getValue(value); // Value has been checked in the super function and is optional\n\n    if (numberValue === null) {\n      return null;\n    } // Invalid input value\n\n\n    if (Number.isNaN(numberValue)) {\n      throw new TypeError(`Failure to convert value for ${this.name}, value, '${value}' is not a parsable number'`);\n    }\n\n    if (this.isValueInRange(numberValue)) {\n      return numberValue;\n    } else {\n      throw new TypeError(`Value, '${numberValue}' is not within allowed limits: min=${this.min} max=${this.max} for '${this.name}'`);\n    }\n  }\n\n  _convertToType(val) {\n    return Number(val);\n  }\n\n  isValueInRange(value) {\n    return value >= this.min && value <= this.max;\n  }\n\n  getRange() {\n    // return this.max - this.min; //TODO brightness has a lower bound of 1, which can generate quirks\n    return this.max;\n  }\n\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/types/RangedNumberType.js"],"names":["BaseType","isValueDefined","RangedNumberType","constructor","config","type","min","typeMin","max","typeMax","getValue","value","numberValue","Number","isNaN","TypeError","name","isValueInRange","_convertToType","val","getRange"],"mappings":"AAAA,SAASA,QAAT,QAAyB,YAAzB;AACA,SAASC,cAAT,QAA+B,YAA/B;AACA,OAAO,MAAMC,gBAAN,SAA+BF,QAA/B,CAAwC;AAC3CG,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,UAAM,EAAE,GAAG;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAAL;AAA+B,SAAGD;AAAlC,KAAN;;AACA,QAAIH,cAAc,CAACG,MAAM,CAACE,GAAR,CAAlB,EAAgC;AAC5B;AACA,WAAKA,GAAL,GAAWF,MAAM,CAACE,GAAlB;AACH,KAHD,MAIK;AACD,WAAKA,GAAL,GAAWF,MAAM,CAACG,OAAlB;AACH;;AACD,QAAIN,cAAc,CAACG,MAAM,CAACI,GAAR,CAAlB,EAAgC;AAC5B;AACA,WAAKA,GAAL,GAAWJ,MAAM,CAACI,GAAlB;AACH,KAHD,MAIK;AACD,WAAKA,GAAL,GAAWJ,MAAM,CAACK,OAAlB;AACH;AACJ;;AACDC,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACZ,UAAMC,WAAW,GAAG,MAAMF,QAAN,CAAeC,KAAf,CAApB,CADY,CAEZ;;AACA,QAAIC,WAAW,KAAK,IAApB,EAA0B;AACtB,aAAO,IAAP;AACH,KALW,CAMZ;;;AACA,QAAIC,MAAM,CAACC,KAAP,CAAaF,WAAb,CAAJ,EAA+B;AAC3B,YAAM,IAAIG,SAAJ,CAAe,gCAA+B,KAAKC,IAAK,aAAYL,KAAM,6BAA1E,CAAN;AACH;;AACD,QAAI,KAAKM,cAAL,CAAoBL,WAApB,CAAJ,EAAsC;AAClC,aAAOA,WAAP;AACH,KAFD,MAGK;AACD,YAAM,IAAIG,SAAJ,CAAe,WAAUH,WAAY,uCAAsC,KAAKN,GAAI,QAAO,KAAKE,GAAI,SAAQ,KAAKQ,IAAK,GAAtH,CAAN;AACH;AACJ;;AACDE,EAAAA,cAAc,CAACC,GAAD,EAAM;AAChB,WAAON,MAAM,CAACM,GAAD,CAAb;AACH;;AACDF,EAAAA,cAAc,CAACN,KAAD,EAAQ;AAClB,WAAOA,KAAK,IAAI,KAAKL,GAAd,IAAqBK,KAAK,IAAI,KAAKH,GAA1C;AACH;;AACDY,EAAAA,QAAQ,GAAG;AACP;AACA,WAAO,KAAKZ,GAAZ;AACH;;AA5C0C","sourcesContent":["import { BaseType } from './BaseType';\nimport { isValueDefined } from './BaseType';\nexport class RangedNumberType extends BaseType {\n    constructor(config) {\n        super({ ...{ type: 'RangedNumber' }, ...config });\n        if (isValueDefined(config.min)) {\n            // @ts-ignore\n            this.min = config.min;\n        }\n        else {\n            this.min = config.typeMin;\n        }\n        if (isValueDefined(config.max)) {\n            // @ts-ignore\n            this.max = config.max;\n        }\n        else {\n            this.max = config.typeMax;\n        }\n    }\n    getValue(value) {\n        const numberValue = super.getValue(value);\n        // Value has been checked in the super function and is optional\n        if (numberValue === null) {\n            return null;\n        }\n        // Invalid input value\n        if (Number.isNaN(numberValue)) {\n            throw new TypeError(`Failure to convert value for ${this.name}, value, '${value}' is not a parsable number'`);\n        }\n        if (this.isValueInRange(numberValue)) {\n            return numberValue;\n        }\n        else {\n            throw new TypeError(`Value, '${numberValue}' is not within allowed limits: min=${this.min} max=${this.max} for '${this.name}'`);\n        }\n    }\n    _convertToType(val) {\n        return Number(val);\n    }\n    isValueInRange(value) {\n        return value >= this.min && value <= this.max;\n    }\n    getRange() {\n        // return this.max - this.min; //TODO brightness has a lower bound of 1, which can generate quirks\n        return this.max;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}