{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rgbToXY = void 0;\n\nconst ApiError_1 = require(\"./ApiError\");\n\nfunction rgbToXY(rgb, colorGamut) {\n  if (!colorGamut) {\n    throw new ApiError_1.ApiError('No color gamut provided, cannot perform conversion of RGB');\n  }\n\n  return _getXYStateFromRGB(rgb[0], rgb[1], rgb[2], colorGamut);\n}\n\nexports.rgbToXY = rgbToXY; //TODO could re-expose the conversion back to RGB from the XY co-ordinates, but that should not be necessary anymore\n// and it was a gross approximation, code is still present below.\n\nclass XY {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  crossProduct(xy) {\n    return this.x * xy.y - this.y * xy.x;\n  }\n\n}\n\nfunction _isInColorGamut(p, gamut) {\n  const v1 = new XY(gamut.green.x - gamut.red.x, gamut.green.y - gamut.red.y),\n        v2 = new XY(gamut.blue.x - gamut.red.x, gamut.blue.y - gamut.red.y),\n        q = new XY(p.x - gamut.red.x, p.y - gamut.red.y);\n  const s = q.crossProduct(v2) / v1.crossProduct(v2),\n        t = v1.crossProduct(q) / v1.crossProduct(v2);\n  return s >= 0.0 && t >= 0.0 && s + t <= 1.0;\n}\n/**\n * Find the closest point on a line. This point will be reproducible by the limits.\n *\n * @param start {XY} The point where the line starts.\n * @param stop {XY} The point where the line ends.\n * @param point {XY} The point which is close to the line.\n * @return {XY} A point that is on the line specified, and closest to the XY provided.\n */\n\n\nfunction _getClosestPoint(start, stop, point) {\n  const AP = new XY(point.x - start.x, point.y - start.y),\n        AB = new XY(stop.x - start.x, stop.y - start.y),\n        ab2 = AB.x * AB.x + AB.y * AB.y,\n        ap_ab = AP.x * AB.x + AP.y * AB.y;\n  let t = ap_ab / ab2;\n\n  if (t < 0.0) {\n    t = 0.0;\n  } else if (t > 1.0) {\n    t = 1.0;\n  }\n\n  return new XY(start.x + AB.x * t, start.y + AB.y * t);\n}\n\nfunction _getDistanceBetweenPoints(pOne, pTwo) {\n  const dx = pOne.x - pTwo.x,\n        dy = pOne.y - pTwo.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction _getXYStateFromRGB(red, green, blue, gamut) {\n  const r = _gammaCorrection(red),\n        g = _gammaCorrection(green),\n        b = _gammaCorrection(blue),\n        X = r * 0.4360747 + g * 0.3850649 + b * 0.0930804,\n        Y = r * 0.2225045 + g * 0.7168786 + b * 0.0406169,\n        Z = r * 0.0139322 + g * 0.0971045 + b * 0.7141733;\n\n  let cx = X / (X + Y + Z),\n      cy = Y / (X + Y + Z);\n  cx = isNaN(cx) ? 0.0 : cx;\n  cy = isNaN(cy) ? 0.0 : cy;\n  let xyPoint = new XY(cx, cy);\n\n  if (!_isInColorGamut(xyPoint, gamut)) {\n    xyPoint = _resolveXYPointForLamp(xyPoint, gamut);\n  }\n\n  return [xyPoint.x, xyPoint.y];\n}\n/**\n * This function is a rough approximation of the reversal of RGB to xy transform. It is a gross approximation and does\n * get close, but is not exact.\n * @param x\n * @param y\n * @param brightness\n * @returns {Array} RGB values\n * @private\n *\n * This function is a modification of the one found at https://github.com/bjohnso5/hue-hacking/blob/master/src/colors.js#L251\n */\n\n\nfunction _getRGBFromXYState(x, y, brightness) {\n  const Y = brightness,\n        X = Y / y * x,\n        Z = Y / y * (1 - x - y);\n  let rgb = [X * 1.612 - Y * 0.203 - Z * 0.302, -X * 0.509 + Y * 1.412 + Z * 0.066, X * 0.026 - Y * 0.072 + Z * 0.962]; // Apply reverse gamma correction.\n\n  rgb = rgb.map(function (x) {\n    return x <= 0.0031308 ? 12.92 * x : (1.0 + 0.055) * Math.pow(x, 1.0 / 2.4) - 0.055;\n  }); // Bring all negative components to zero.\n\n  rgb = rgb.map(function (x) {\n    return Math.max(0, x);\n  }); // If one component is greater than 1, weight components by that value.\n\n  const max = Math.max(rgb[0], rgb[1], rgb[2]);\n\n  if (max > 1) {\n    rgb = rgb.map(function (x) {\n      return x / max;\n    });\n  }\n\n  rgb = rgb.map(function (x) {\n    return Math.floor(x * 255);\n  });\n  return rgb;\n}\n/**\n * When a color is outside the limits, find the closest point on each line in the CIE 1931 'triangle'.\n * @param point {XY} The point that is outside the limits\n * @param gamut The limits of the bulb (red, green and blue XY points).\n * @returns {XY}\n */\n\n\nfunction _resolveXYPointForLamp(point, gamut) {\n  const pAB = _getClosestPoint(gamut.red, gamut.green, point),\n        pAC = _getClosestPoint(gamut.blue, gamut.red, point),\n        pBC = _getClosestPoint(gamut.green, gamut.blue, point),\n        dAB = _getDistanceBetweenPoints(point, pAB),\n        dAC = _getDistanceBetweenPoints(point, pAC),\n        dBC = _getDistanceBetweenPoints(point, pBC);\n\n  let lowest = dAB,\n      closestPoint = pAB;\n\n  if (dAC < lowest) {\n    lowest = dAC;\n    closestPoint = pAC;\n  }\n\n  if (dBC < lowest) {\n    closestPoint = pBC;\n  }\n\n  return closestPoint;\n}\n\nfunction _gammaCorrection(value) {\n  if (value > 0.04045) {\n    return Math.pow((value + 0.055) / (1.0 + 0.055), 2.4);\n  } else {\n    return value / 12.92;\n  }\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/node-hue-api/dist/cjs/rgb.js"],"names":["Object","defineProperty","exports","value","rgbToXY","ApiError_1","require","rgb","colorGamut","ApiError","_getXYStateFromRGB","XY","constructor","x","y","crossProduct","xy","_isInColorGamut","p","gamut","v1","green","red","v2","blue","q","s","t","_getClosestPoint","start","stop","point","AP","AB","ab2","ap_ab","_getDistanceBetweenPoints","pOne","pTwo","dx","dy","Math","sqrt","r","_gammaCorrection","g","b","X","Y","Z","cx","cy","isNaN","xyPoint","_resolveXYPointForLamp","_getRGBFromXYState","brightness","map","pow","max","floor","pAB","pAC","pBC","dAB","dAC","dBC","lowest","closestPoint"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rgbToXY = void 0;\nconst ApiError_1 = require(\"./ApiError\");\nfunction rgbToXY(rgb, colorGamut) {\n    if (!colorGamut) {\n        throw new ApiError_1.ApiError('No color gamut provided, cannot perform conversion of RGB');\n    }\n    return _getXYStateFromRGB(rgb[0], rgb[1], rgb[2], colorGamut);\n}\nexports.rgbToXY = rgbToXY;\n//TODO could re-expose the conversion back to RGB from the XY co-ordinates, but that should not be necessary anymore\n// and it was a gross approximation, code is still present below.\nclass XY {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    crossProduct(xy) {\n        return (this.x * xy.y) - (this.y * xy.x);\n    }\n}\nfunction _isInColorGamut(p, gamut) {\n    const v1 = new XY((gamut.green.x - gamut.red.x), (gamut.green.y - gamut.red.y)), v2 = new XY((gamut.blue.x - gamut.red.x), (gamut.blue.y - gamut.red.y)), q = new XY(p.x - gamut.red.x, p.y - gamut.red.y);\n    const s = q.crossProduct(v2) / v1.crossProduct(v2), t = v1.crossProduct(q) / v1.crossProduct(v2);\n    return (s >= 0.0) && (t >= 0.0) && (s + t <= 1.0);\n}\n/**\n * Find the closest point on a line. This point will be reproducible by the limits.\n *\n * @param start {XY} The point where the line starts.\n * @param stop {XY} The point where the line ends.\n * @param point {XY} The point which is close to the line.\n * @return {XY} A point that is on the line specified, and closest to the XY provided.\n */\nfunction _getClosestPoint(start, stop, point) {\n    const AP = new XY(point.x - start.x, point.y - start.y), AB = new XY(stop.x - start.x, stop.y - start.y), ab2 = AB.x * AB.x + AB.y * AB.y, ap_ab = AP.x * AB.x + AP.y * AB.y;\n    let t = ap_ab / ab2;\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    else if (t > 1.0) {\n        t = 1.0;\n    }\n    return new XY((start.x + AB.x * t), (start.y + AB.y * t));\n}\nfunction _getDistanceBetweenPoints(pOne, pTwo) {\n    const dx = pOne.x - pTwo.x, dy = pOne.y - pTwo.y;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nfunction _getXYStateFromRGB(red, green, blue, gamut) {\n    const r = _gammaCorrection(red), g = _gammaCorrection(green), b = _gammaCorrection(blue), X = r * 0.4360747 + g * 0.3850649 + b * 0.0930804, Y = r * 0.2225045 + g * 0.7168786 + b * 0.0406169, Z = r * 0.0139322 + g * 0.0971045 + b * 0.7141733;\n    let cx = X / (X + Y + Z), cy = Y / (X + Y + Z);\n    cx = isNaN(cx) ? 0.0 : cx;\n    cy = isNaN(cy) ? 0.0 : cy;\n    let xyPoint = new XY(cx, cy);\n    if (!_isInColorGamut(xyPoint, gamut)) {\n        xyPoint = _resolveXYPointForLamp(xyPoint, gamut);\n    }\n    return [xyPoint.x, xyPoint.y];\n}\n/**\n * This function is a rough approximation of the reversal of RGB to xy transform. It is a gross approximation and does\n * get close, but is not exact.\n * @param x\n * @param y\n * @param brightness\n * @returns {Array} RGB values\n * @private\n *\n * This function is a modification of the one found at https://github.com/bjohnso5/hue-hacking/blob/master/src/colors.js#L251\n */\nfunction _getRGBFromXYState(x, y, brightness) {\n    const Y = brightness, X = (Y / y) * x, Z = (Y / y) * (1 - x - y);\n    let rgb = [\n        X * 1.612 - Y * 0.203 - Z * 0.302,\n        -X * 0.509 + Y * 1.412 + Z * 0.066,\n        X * 0.026 - Y * 0.072 + Z * 0.962\n    ];\n    // Apply reverse gamma correction.\n    rgb = rgb.map(function (x) {\n        return (x <= 0.0031308) ? (12.92 * x) : ((1.0 + 0.055) * Math.pow(x, (1.0 / 2.4)) - 0.055);\n    });\n    // Bring all negative components to zero.\n    rgb = rgb.map(function (x) {\n        return Math.max(0, x);\n    });\n    // If one component is greater than 1, weight components by that value.\n    const max = Math.max(rgb[0], rgb[1], rgb[2]);\n    if (max > 1) {\n        rgb = rgb.map(function (x) {\n            return x / max;\n        });\n    }\n    rgb = rgb.map(function (x) {\n        return Math.floor(x * 255);\n    });\n    return rgb;\n}\n/**\n * When a color is outside the limits, find the closest point on each line in the CIE 1931 'triangle'.\n * @param point {XY} The point that is outside the limits\n * @param gamut The limits of the bulb (red, green and blue XY points).\n * @returns {XY}\n */\nfunction _resolveXYPointForLamp(point, gamut) {\n    const pAB = _getClosestPoint(gamut.red, gamut.green, point), pAC = _getClosestPoint(gamut.blue, gamut.red, point), pBC = _getClosestPoint(gamut.green, gamut.blue, point), dAB = _getDistanceBetweenPoints(point, pAB), dAC = _getDistanceBetweenPoints(point, pAC), dBC = _getDistanceBetweenPoints(point, pBC);\n    let lowest = dAB, closestPoint = pAB;\n    if (dAC < lowest) {\n        lowest = dAC;\n        closestPoint = pAC;\n    }\n    if (dBC < lowest) {\n        closestPoint = pBC;\n    }\n    return closestPoint;\n}\nfunction _gammaCorrection(value) {\n    if (value > 0.04045) {\n        return Math.pow((value + 0.055) / (1.0 + 0.055), 2.4);\n    }\n    else {\n        return value / 12.92;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}