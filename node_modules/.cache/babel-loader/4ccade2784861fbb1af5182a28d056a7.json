{"ast":null,"code":"import { BridgeTime } from './BridgeTime';\nimport { HueTime } from './HueTime';\nimport { RECURRING_TIMER_REGEX, REOCCURRANCE_ATTRIBUTE } from './timeUtil';\nimport { HueBridgeModelError } from '../HueBridgeModelError';\nexport class RecurringTimer extends BridgeTime {\n  constructor(value) {\n    super();\n    this.time = new HueTime();\n    this.reoccurance = 0;\n\n    if (value) {\n      this.value = value;\n    }\n  }\n\n  static matches(value) {\n    return RECURRING_TIMER_REGEX.test(value);\n  }\n\n  set value(value) {\n    if (value instanceof RecurringTimer) {\n      // Use the string value and re-enter this function\n      this.value = value.toString();\n    } else if (value instanceof Date) {\n      this.time.fromDate(value);\n    } else {\n      const parsed = RECURRING_TIMER_REGEX.exec(value);\n\n      if (parsed) {\n        // @ts-ignore\n        this.time.hours = parsed.groups.hours; // @ts-ignore\n\n        this.time.minutes = parsed.groups.minutes; // @ts-ignore\n\n        this.time.seconds = parsed.groups.seconds; // @ts-ignore\n\n        this.reoccurs(parsed.groups.times.length === 0 ? 0 : parsed.groups.times);\n      } else {\n        throw new HueBridgeModelError(`Cannnot create a Timer from ${value}`);\n      }\n    }\n  }\n\n  hours(value) {\n    this.time.hours = value;\n    return this;\n  }\n\n  minutes(value) {\n    this.time.minutes = value;\n    return this;\n  }\n\n  seconds(value) {\n    this.time.seconds = value;\n    return this;\n  }\n\n  reoccurs(value) {\n    // @ts-ignore\n    this.reoccurance = REOCCURRANCE_ATTRIBUTE.getValue(value);\n    return this;\n  }\n\n  toString() {\n    let limit = '';\n    const reoccurs = this.reoccurance;\n\n    if (reoccurs !== 0) {\n      limit = `${reoccurs}`.padStart(2, '0');\n    }\n\n    return `R${limit}/PT${this.time.toString()}`;\n  }\n\n}","map":{"version":3,"sources":["/Users/clusk/Documents/OtherRepositories/StrikeElectric/node_modules/@peter-murray/hue-bridge-model/dist/esm/time/RecurringTimer.js"],"names":["BridgeTime","HueTime","RECURRING_TIMER_REGEX","REOCCURRANCE_ATTRIBUTE","HueBridgeModelError","RecurringTimer","constructor","value","time","reoccurance","matches","test","toString","Date","fromDate","parsed","exec","hours","groups","minutes","seconds","reoccurs","times","length","getValue","limit","padStart"],"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA,SAASC,qBAAT,EAAgCC,sBAAhC,QAA8D,YAA9D;AACA,SAASC,mBAAT,QAAoC,wBAApC;AACA,OAAO,MAAMC,cAAN,SAA6BL,UAA7B,CAAwC;AAC3CM,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf;AACA,SAAKC,IAAL,GAAY,IAAIP,OAAJ,EAAZ;AACA,SAAKQ,WAAL,GAAmB,CAAnB;;AACA,QAAIF,KAAJ,EAAW;AACP,WAAKA,KAAL,GAAaA,KAAb;AACH;AACJ;;AACa,SAAPG,OAAO,CAACH,KAAD,EAAQ;AAClB,WAAOL,qBAAqB,CAACS,IAAtB,CAA2BJ,KAA3B,CAAP;AACH;;AACQ,MAALA,KAAK,CAACA,KAAD,EAAQ;AACb,QAAIA,KAAK,YAAYF,cAArB,EAAqC;AACjC;AACA,WAAKE,KAAL,GAAaA,KAAK,CAACK,QAAN,EAAb;AACH,KAHD,MAIK,IAAIL,KAAK,YAAYM,IAArB,EAA2B;AAC5B,WAAKL,IAAL,CAAUM,QAAV,CAAmBP,KAAnB;AACH,KAFI,MAGA;AACD,YAAMQ,MAAM,GAAGb,qBAAqB,CAACc,IAAtB,CAA2BT,KAA3B,CAAf;;AACA,UAAIQ,MAAJ,EAAY;AACR;AACA,aAAKP,IAAL,CAAUS,KAAV,GAAkBF,MAAM,CAACG,MAAP,CAAcD,KAAhC,CAFQ,CAGR;;AACA,aAAKT,IAAL,CAAUW,OAAV,GAAoBJ,MAAM,CAACG,MAAP,CAAcC,OAAlC,CAJQ,CAKR;;AACA,aAAKX,IAAL,CAAUY,OAAV,GAAoBL,MAAM,CAACG,MAAP,CAAcE,OAAlC,CANQ,CAOR;;AACA,aAAKC,QAAL,CAAcN,MAAM,CAACG,MAAP,CAAcI,KAAd,CAAoBC,MAApB,KAA+B,CAA/B,GAAmC,CAAnC,GAAuCR,MAAM,CAACG,MAAP,CAAcI,KAAnE;AACH,OATD,MAUK;AACD,cAAM,IAAIlB,mBAAJ,CAAyB,+BAA8BG,KAAM,EAA7D,CAAN;AACH;AACJ;AACJ;;AACDU,EAAAA,KAAK,CAACV,KAAD,EAAQ;AACT,SAAKC,IAAL,CAAUS,KAAV,GAAkBV,KAAlB;AACA,WAAO,IAAP;AACH;;AACDY,EAAAA,OAAO,CAACZ,KAAD,EAAQ;AACX,SAAKC,IAAL,CAAUW,OAAV,GAAoBZ,KAApB;AACA,WAAO,IAAP;AACH;;AACDa,EAAAA,OAAO,CAACb,KAAD,EAAQ;AACX,SAAKC,IAAL,CAAUY,OAAV,GAAoBb,KAApB;AACA,WAAO,IAAP;AACH;;AACDc,EAAAA,QAAQ,CAACd,KAAD,EAAQ;AACZ;AACA,SAAKE,WAAL,GAAmBN,sBAAsB,CAACqB,QAAvB,CAAgCjB,KAAhC,CAAnB;AACA,WAAO,IAAP;AACH;;AACDK,EAAAA,QAAQ,GAAG;AACP,QAAIa,KAAK,GAAG,EAAZ;AACA,UAAMJ,QAAQ,GAAG,KAAKZ,WAAtB;;AACA,QAAIY,QAAQ,KAAK,CAAjB,EAAoB;AAChBI,MAAAA,KAAK,GAAI,GAAEJ,QAAS,EAAZ,CAAcK,QAAd,CAAuB,CAAvB,EAA0B,GAA1B,CAAR;AACH;;AACD,WAAQ,IAAGD,KAAM,MAAK,KAAKjB,IAAL,CAAUI,QAAV,EAAqB,EAA3C;AACH;;AA7D0C","sourcesContent":["import { BridgeTime } from './BridgeTime';\nimport { HueTime } from './HueTime';\nimport { RECURRING_TIMER_REGEX, REOCCURRANCE_ATTRIBUTE } from './timeUtil';\nimport { HueBridgeModelError } from '../HueBridgeModelError';\nexport class RecurringTimer extends BridgeTime {\n    constructor(value) {\n        super();\n        this.time = new HueTime();\n        this.reoccurance = 0;\n        if (value) {\n            this.value = value;\n        }\n    }\n    static matches(value) {\n        return RECURRING_TIMER_REGEX.test(value);\n    }\n    set value(value) {\n        if (value instanceof RecurringTimer) {\n            // Use the string value and re-enter this function\n            this.value = value.toString();\n        }\n        else if (value instanceof Date) {\n            this.time.fromDate(value);\n        }\n        else {\n            const parsed = RECURRING_TIMER_REGEX.exec(value);\n            if (parsed) {\n                // @ts-ignore\n                this.time.hours = parsed.groups.hours;\n                // @ts-ignore\n                this.time.minutes = parsed.groups.minutes;\n                // @ts-ignore\n                this.time.seconds = parsed.groups.seconds;\n                // @ts-ignore\n                this.reoccurs(parsed.groups.times.length === 0 ? 0 : parsed.groups.times);\n            }\n            else {\n                throw new HueBridgeModelError(`Cannnot create a Timer from ${value}`);\n            }\n        }\n    }\n    hours(value) {\n        this.time.hours = value;\n        return this;\n    }\n    minutes(value) {\n        this.time.minutes = value;\n        return this;\n    }\n    seconds(value) {\n        this.time.seconds = value;\n        return this;\n    }\n    reoccurs(value) {\n        // @ts-ignore\n        this.reoccurance = REOCCURRANCE_ATTRIBUTE.getValue(value);\n        return this;\n    }\n    toString() {\n        let limit = '';\n        const reoccurs = this.reoccurance;\n        if (reoccurs !== 0) {\n            limit = `${reoccurs}`.padStart(2, '0');\n        }\n        return `R${limit}/PT${this.time.toString()}`;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}